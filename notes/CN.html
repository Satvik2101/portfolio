<!DOCTYPE html>
<html ontouchmove="" xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Satvik Gupta" />
  <title>Computer Networks</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
  </style>
  <link rel="stylesheet" href="styles.css" />
  
  <script
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js"
  type="text/javascript"></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
    
    <div id="navbar" onclick="">

    <div id="navbar_text">
        .satvik
    </div>
    <div id="navbar_links">
        <div class="navbar_link" id="home_link">
            <a href="/#home" target="_self">Home</a>
        </div>
        <div class="navbar_link" id="workexp_link">
            <a href="/#workexp" target="_self">
                Work Experience
            </a>
        </div>
        <div class=" navbar_link" id="projects_link">
            <a href="/#projects" target="_self">Projects</a>
        </div>
        <div class=" navbar_link" id="notes_link">
        <a href="/notes" target="_self">Notes</a>
    </div>
        <div class=" navbar_link" id="contacts_link">
            <a href="/#contact" target="_self">Contact</a>
        </div>
      
        
    </div>
</div>

<header id="title-block-header">
<h1 class="title">Computer Networks</h1>
<p class="author">Satvik Gupta</p>
</header><div id="container">
<nav id="TOC" role="doc-toc"><div class="pdf_link_container"><a class="pdf_link" href="/notes/pdfs/CN.pdf">Download as PDF</a></div>
<ul>
<li><a href="#introduction" id="toc-introduction">Introduction</a>
<ul>
<li><a href="#communication-link"
id="toc-communication-link">Communication link:</a></li>
<li><a href="#goals-of-networks" id="toc-goals-of-networks">Goals of
Networks</a></li>
<li><a href="#data-communication" id="toc-data-communication">Data
communication</a>
<ul>
<li><a href="#components-of-effective-data-communication"
id="toc-components-of-effective-data-communication">Components of
Effective Data Communication</a></li>
<li><a href="#components-of-data-communication-system"
id="toc-components-of-data-communication-system">Components of Data
communication system</a></li>
<li><a href="#types-of-communication"
id="toc-types-of-communication">Types of Communication</a></li>
<li><a href="#physical-structure" id="toc-physical-structure">Physical
Structure</a></li>
</ul></li>
</ul></li>
<li><a href="#physical-topology" id="toc-physical-topology">Physical
Topology</a>
<ul>
<li><a href="#bus-topology" id="toc-bus-topology">Bus Topology</a></li>
<li><a href="#ring-topology" id="toc-ring-topology">Ring
Topology</a></li>
<li><a href="#star-topology" id="toc-star-topology">Star
Topology</a></li>
<li><a href="#mesh-topology" id="toc-mesh-topology">Mesh
Topology</a></li>
<li><a href="#tree-topology" id="toc-tree-topology">Tree
Topology</a></li>
</ul></li>
<li><a href="#networks-based-on-geographical-area"
id="toc-networks-based-on-geographical-area">Networks Based on
Geographical Area</a></li>
<li><a href="#osi-model---open-systems-interconnection"
id="toc-osi-model---open-systems-interconnection">OSI Model - Open
Systems Interconnection</a>
<ul>
<li><a href="#data-in-layers" id="toc-data-in-layers">Data in
layers:</a></li>
</ul></li>
<li><a href="#physical-layer" id="toc-physical-layer">Physical Layer</a>
<ul>
<li><a href="#transmission-media"
id="toc-transmission-media">Transmission Media</a>
<ul>
<li><a href="#wiredguided-media"
id="toc-wiredguided-media"><strong>Wired/Guided Media</strong>:</a></li>
<li><a href="#wirelessunguided-media"
id="toc-wirelessunguided-media"><strong>Wireless/Unguided
Media</strong>:</a></li>
</ul></li>
<li><a href="#propagation-methods"
id="toc-propagation-methods">Propagation Methods</a></li>
<li><a href="#bands" id="toc-bands">Bands</a></li>
<li><a href="#switched-networks" id="toc-switched-networks">Switched
Networks</a></li>
<li><a href="#network-architecture"
id="toc-network-architecture">Network Architecture</a></li>
<li><a href="#types-of-communication-on-the-basis-of-connection"
id="toc-types-of-communication-on-the-basis-of-connection">Types of
Communication on the basis of Connection</a>
<ul>
<li><a href="#connection-oriented"
id="toc-connection-oriented">Connection-Oriented</a></li>
<li><a href="#connectionless"
id="toc-connectionless">Connectionless</a></li>
</ul></li>
</ul></li>
<li><a href="#tcpip-stack" id="toc-tcpip-stack">TCP/IP Stack</a>
<ul>
<li><a href="#internet-protocol-ip"
id="toc-internet-protocol-ip">Internet Protocol (IP)</a></li>
<li><a href="#transmission-control-protocol-tcp"
id="toc-transmission-control-protocol-tcp">Transmission Control Protocol
(TCP)</a></li>
<li><a href="#user-datagram-protocol-udp"
id="toc-user-datagram-protocol-udp">User Datagram Protocol
(UDP)</a></li>
</ul></li>
<li><a href="#data-link-layer" id="toc-data-link-layer">Data Link
Layer</a>
<ul>
<li><a href="#delay" id="toc-delay">Delay</a>
<ul>
<li><a href="#transmission-delay"
id="toc-transmission-delay">Transmission Delay</a></li>
<li><a href="#propagation-delay" id="toc-propagation-delay">Propagation
Delay</a></li>
<li><a href="#queueing-delay" id="toc-queueing-delay">Queueing
Delay</a></li>
<li><a href="#processing-delay" id="toc-processing-delay">Processing
Delay</a></li>
</ul></li>
<li><a href="#framing-techniques" id="toc-framing-techniques">Framing
Techniques</a>
<ul>
<li><a href="#character-count" id="toc-character-count">Character
Count</a></li>
<li><a href="#flag-character-stuffingbyte-stuffing"
id="toc-flag-character-stuffingbyte-stuffing">Flag (Character
Stuffing/Byte Stuffing)</a></li>
<li><a href="#bit-stuffing" id="toc-bit-stuffing">Bit Stuffing</a></li>
</ul></li>
<li><a href="#error-detection-and-control"
id="toc-error-detection-and-control">Error Detection and Control</a>
<ul>
<li><a href="#parity-check" id="toc-parity-check">Parity Check</a></li>
<li><a href="#hamming-code" id="toc-hamming-code">Hamming Code</a></li>
<li><a href="#checksum" id="toc-checksum">Checksum</a></li>
<li><a href="#crc-cyclic-redundancy-check"
id="toc-crc-cyclic-redundancy-check">CRC (Cyclic Redundancy
Check)</a></li>
</ul></li>
<li><a href="#flow-control" id="toc-flow-control">Flow Control</a>
<ul>
<li><a href="#stop-wait-arq-automatic-repeat-request"
id="toc-stop-wait-arq-automatic-repeat-request">Stop &amp; Wait ARQ
(Automatic Repeat ReQuest)</a></li>
<li><a href="#formulas" id="toc-formulas">Formulas</a></li>
<li><a href="#go-back-n" id="toc-go-back-n">Go Back N</a></li>
<li><a href="#selective-repeat-sr"
id="toc-selective-repeat-sr">Selective Repeat (SR)</a></li>
<li><a href="#data-encoding-techniques"
id="toc-data-encoding-techniques">Data Encoding Techniques</a></li>
</ul></li>
</ul></li>
<li><a href="#media-access-sublayer"
id="toc-media-access-sublayer">Media Access Sublayer</a>
<ul>
<li><a href="#media-access-control-and-multiple-access-protocols"
id="toc-media-access-control-and-multiple-access-protocols">Media Access
Control and Multiple Access Protocols</a></li>
<li><a href="#random-access-contention-methods"
id="toc-random-access-contention-methods">Random Access/ Contention
Methods</a>
<ul>
<li><a href="#pure-aloha" id="toc-pure-aloha">Pure Aloha</a></li>
<li><a href="#slotted-aloha" id="toc-slotted-aloha">Slotted
Aloha</a></li>
<li><a href="#csma-carrier-sense-multiple-access"
id="toc-csma-carrier-sense-multiple-access">CSMA (Carrier Sense Multiple
Access)</a></li>
<li><a href="#persistence-methods-for-csma"
id="toc-persistence-methods-for-csma">Persistence Methods for
CSMA</a></li>
<li><a href="#csma-with-collision-detection-csmacd"
id="toc-csma-with-collision-detection-csmacd">CSMA with Collision
Detection (CSMA/CD)</a></li>
</ul></li>
</ul></li>
<li><a href="#network-layer" id="toc-network-layer">Network Layer</a>
<ul>
<li><a href="#classful-addressing" id="toc-classful-addressing">Classful
Addressing</a>
<ul>
<li><a href="#class-a" id="toc-class-a">Class A</a></li>
<li><a href="#class-b" id="toc-class-b">Class B</a></li>
<li><a href="#class-c" id="toc-class-c">Class C</a></li>
<li><a href="#class-d" id="toc-class-d">Class D</a></li>
<li><a href="#class-e" id="toc-class-e">Class E</a></li>
</ul></li>
<li><a href="#classless-addressing"
id="toc-classless-addressing">Classless Addressing</a>
<ul>
<li><a href="#rules-for-classless-addressing"
id="toc-rules-for-classless-addressing">Rules for Classless
Addressing</a></li>
</ul></li>
<li><a href="#subnetting" id="toc-subnetting">Subnetting</a>
<ul>
<li><a href="#subnetting-in-classful-addressing"
id="toc-subnetting-in-classful-addressing">Subnetting in Classful
Addressing</a></li>
<li><a href="#subnetting-in-classless-addressing"
id="toc-subnetting-in-classless-addressing">Subnetting in Classless
Addressing</a></li>
<li><a href="#variable-length-subnet-masking-vlsm"
id="toc-variable-length-subnet-masking-vlsm">Variable Length Subnet
Masking (VLSM)</a></li>
</ul></li>
<li><a href="#header-formats-for-ip-protocols"
id="toc-header-formats-for-ip-protocols">Header Formats for IP
Protocols</a>
<ul>
<li><a href="#ipv4-header-format" id="toc-ipv4-header-format">IPv4
Header Format</a></li>
<li><a href="#ipv6-header" id="toc-ipv6-header">IPv6 Header</a></li>
</ul></li>
<li><a href="#congestion-control" id="toc-congestion-control">Congestion
Control</a>
<ul>
<li><a href="#leaky-bucket" id="toc-leaky-bucket">Leaky Bucket</a></li>
<li><a href="#token-bucket" id="toc-token-bucket">Token Bucket</a></li>
</ul></li>
<li><a href="#routing-protocols" id="toc-routing-protocols">Routing
Protocols</a>
<ul>
<li><a href="#distance-vector-routing-dvr"
id="toc-distance-vector-routing-dvr">Distance Vector Routing
(DVR)</a></li>
<li><a href="#link-state-routing" id="toc-link-state-routing">Link State
Routing</a></li>
<li><a href="#routing-in-subnets" id="toc-routing-in-subnets">Routing in
Subnets</a></li>
</ul></li>
<li><a href="#network-protocols" id="toc-network-protocols">Network
Protocols</a>
<ul>
<li><a href="#arp-address-resolution-protocol"
id="toc-arp-address-resolution-protocol">ARP (Address Resolution
Protocol)</a></li>
<li><a href="#nat-network-address-translation"
id="toc-nat-network-address-translation">NAT (Network Address
Translation)</a></li>
</ul></li>
</ul></li>
<li><a href="#transport-layer" id="toc-transport-layer">Transport
Layer</a>
<ul>
<li><a href="#responsibilities"
id="toc-responsibilities">Responsibilities</a></li>
<li><a href="#socket-address-and-port-numbers"
id="toc-socket-address-and-port-numbers">Socket Address and Port
Numbers</a>
<ul>
<li><a href="#port-number-types" id="toc-port-number-types">Port Number
Types</a></li>
<li><a href="#section" id="toc-section"></a></li>
</ul></li>
<li><a href="#tcp-transmission-control-protocol"
id="toc-tcp-transmission-control-protocol">TCP (Transmission Control
Protocol)</a>
<ul>
<li><a href="#characteristics"
id="toc-characteristics">Characteristics</a></li>
<li><a href="#tcp-header" id="toc-tcp-header">TCP Header</a></li>
<li><a href="#tcp-connection-establishment"
id="toc-tcp-connection-establishment">TCP Connection
Establishment</a></li>
<li><a href="#tcp-connection-termination"
id="toc-tcp-connection-termination">TCP Connection Termination</a></li>
<li><a href="#tcp-congestion-control"
id="toc-tcp-congestion-control">TCP Congestion Control</a></li>
<li><a href="#wrap-around" id="toc-wrap-around">Wrap-Around</a></li>
<li><a href="#tcp-window-scaling" id="toc-tcp-window-scaling">TCP Window
Scaling</a></li>
<li><a href="#tcp-timers" id="toc-tcp-timers">TCP Timers</a></li>
</ul></li>
<li><a href="#udp" id="toc-udp">UDP</a>
<ul>
<li><a href="#characteristics-1"
id="toc-characteristics-1">Characteristics</a></li>
<li><a href="#header" id="toc-header">Header</a></li>
<li><a href="#udp-applications" id="toc-udp-applications">UDP
Applications</a></li>
</ul></li>
<li><a href="#tcp-vs-udp" id="toc-tcp-vs-udp">TCP vs UDP</a></li>
</ul></li>
<li><a href="#application-layer" id="toc-application-layer">Application
Layer</a>
<ul>
<li><a href="#paradigms" id="toc-paradigms">Paradigms</a></li>
<li><a href="#file-transferring" id="toc-file-transferring">File
Transferring</a>
<ul>
<li><a href="#ftp-file-transfer-protocol"
id="toc-ftp-file-transfer-protocol">FTP (File Transfer
Protocol)</a></li>
<li><a href="#ftam-file-transfer-access-management"
id="toc-ftam-file-transfer-access-management">FTAM (File Transfer Access
Management)</a></li>
</ul></li>
<li><a href="#email" id="toc-email">Email</a>
<ul>
<li><a href="#smtp" id="toc-smtp">SMTP</a></li>
<li><a href="#message-access-agents---pop-and-imap"
id="toc-message-access-agents---pop-and-imap">Message Access Agents -
POP and IMAP</a></li>
<li><a href="#mime" id="toc-mime">MIME</a></li>
<li><a href="#extended-smtp-esmtp-vs-smtp"
id="toc-extended-smtp-esmtp-vs-smtp">Extended SMTP (ESMTP) vs
SMTP</a></li>
</ul></li>
<li><a href="#dns" id="toc-dns">DNS</a>
<ul>
<li><a href="#dns-server-hierarchy" id="toc-dns-server-hierarchy">DNS
Server Hierarchy</a></li>
<li><a href="#dns-name-hierarchy" id="toc-dns-name-hierarchy">DNS Name
Hierarchy</a></li>
</ul></li>
</ul></li>
<li><a href="#session-layer" id="toc-session-layer">Session Layer</a>
<ul>
<li><a href="#functions-of-session-layer"
id="toc-functions-of-session-layer">Functions of Session Layer</a></li>
<li><a href="#design-issues" id="toc-design-issues">Design
Issues</a></li>
<li><a href="#rpc-remote-procedure-call"
id="toc-rpc-remote-procedure-call">RPC (Remote Procedure Call)</a>
<ul>
<li><a href="#issues-in-rpc" id="toc-issues-in-rpc">Issues in
RPC</a></li>
</ul></li>
<li><a href="#types-of-rpc" id="toc-types-of-rpc">Types of RPC</a>
<ul>
<li><a href="#synchronous-rpc" id="toc-synchronous-rpc">Synchronous
RPC</a></li>
<li><a href="#asynchronous-rpc" id="toc-asynchronous-rpc">Asynchronous
RPC</a></li>
<li><a href="#one-way-rpc" id="toc-one-way-rpc">One-Way RPC</a></li>
<li><a href="#deferred-synchronous-rpc"
id="toc-deferred-synchronous-rpc">Deferred Synchronous RPC</a></li>
</ul></li>
<li><a href="#failure-semantics-in-rpc"
id="toc-failure-semantics-in-rpc">Failure Semantics in RPC</a></li>
</ul></li>
<li><a href="#presentation-layer---security"
id="toc-presentation-layer---security">Presentation Layer - Security</a>
<ul>
<li><a href="#types-of-cryptosystems"
id="toc-types-of-cryptosystems">Types of Cryptosystems</a>
<ul>
<li><a href="#symmetric" id="toc-symmetric">Symmetric</a></li>
<li><a href="#asymmetric" id="toc-asymmetric">Asymmetric</a></li>
</ul></li>
<li><a href="#types-of-ciphers" id="toc-types-of-ciphers">Types of
Ciphers</a>
<ul>
<li><a href="#substitution-ciphers"
id="toc-substitution-ciphers">Substitution Ciphers</a></li>
<li><a href="#transposition-ciphers"
id="toc-transposition-ciphers">Transposition Ciphers</a></li>
<li><a href="#one-time-pad" id="toc-one-time-pad">One-Time Pad</a></li>
</ul></li>
<li><a href="#rsa" id="toc-rsa">RSA</a>
<ul>
<li><a href="#steps" id="toc-steps">Steps</a></li>
<li><a href="#usage" id="toc-usage">Usage</a></li>
<li><a href="#properties-of-rsa" id="toc-properties-of-rsa">Properties
of RSA</a></li>
</ul></li>
<li><a href="#securely-sending-messages-secure-channels"
id="toc-securely-sending-messages-secure-channels">Securely sending
messages (Secure Channels)</a>
<ul>
<li><a href="#digital-signatures" id="toc-digital-signatures">Digital
Signatures</a></li>
<li><a href="#diffie-hellman-key-exchange"
id="toc-diffie-hellman-key-exchange">Diffie-Hellman Key
Exchange</a></li>
</ul></li>
</ul></li>
</ul>
</nav><div id="data">
<h2 id="introduction">Introduction</h2>
<p><strong>Network</strong>: Connection between objects or a group of
objects</p>
<p><strong>Computer network</strong>: A set of communication elements
connected by communication link.</p>
<h3 id="communication-link">Communication link:</h3>
<ul>
<li><p><strong>Wired</strong>: Optical Fiber, Coaxial Fiber, Twisted
pair cable.</p></li>
<li><p><strong>Wireless</strong>: Radio wave, satellite connection,
microwave.</p></li>
</ul>
<h3 id="goals-of-networks">Goals of Networks</h3>
<ul>
<li>Efficient resource sharing</li>
<li>Scalable</li>
<li>Reliability</li>
<li>Communication</li>
<li>Application of Networks</li>
<li>Remote data access.</li>
<li>Remote software access.</li>
<li>Emailing</li>
<li>FIle transfer</li>
</ul>
<h3 id="data-communication">Data communication</h3>
<p>It is the exchange of data between two or more devices via some
transmission medium</p>
<h4 id="components-of-effective-data-communication">Components of
Effective Data Communication</h4>
<ul>
<li>Delivery: The data should be delivered to the destination it was
intended to.</li>
<li>Accuracy</li>
<li>Timeliness</li>
<li>Jitter free</li>
</ul>
<h4 id="components-of-data-communication-system">Components of Data
communication system</h4>
<ul>
<li>Sender</li>
<li>Receiver</li>
<li>Message</li>
<li>Protocols</li>
<li>Communication/Transmission medium</li>
</ul>
<h4 id="types-of-communication">Types of Communication</h4>
<ul>
<li>Simplex: Unidirectional communication.</li>
<li>Half Duplex: Bidirectional communication but only one direction at a
time.</li>
<li>Full Duplex: Two simplex connections in opposite directions.</li>
</ul>
<h4 id="physical-structure">Physical Structure</h4>
<ul>
<li>Point to point</li>
<li>Multipoint</li>
</ul>
<hr />
<h2 id="physical-topology">Physical Topology</h2>
<p>It tells how systems are physically connected through links. It is a
geometric representation of the network.</p>
<h3 id="bus-topology">Bus Topology</h3>
<p>Only one connection.</p>
<figure>
<img src="../images/cn/bus_topology.png" width="200"
alt="Bus Topology" />
<figcaption aria-hidden="true">Bus Topology</figcaption>
</figure>
<p><strong><em>Advantages</em></strong></p>
<ul>
<li>Easy to install</li>
<li>Cheap</li>
<li>Easy to expand</li>
</ul>
<p><strong><em>Disadvantages</em></strong></p>
<ul>
<li>Only one device can transmit at a time, which makes it low
speed.</li>
<li>Single point of failure - faulty cable can bring down the whole
system.</li>
</ul>
<h3 id="ring-topology">Ring Topology</h3>
<figure>
<img src="../images/cn/ring_topology.png" width="200"
alt="Ring Topology" />
<figcaption aria-hidden="true">Ring Topology</figcaption>
</figure>
<p>Tokens are used to transfer data. Only one system can hold the token
at a time. Token passing is done.</p>
<p><strong>*Advantages</strong></p>
<ul>
<li>Cheap</li>
</ul>
<p><strong><em>Disadvantages</em></strong></p>
<ul>
<li>Not easy to install.</li>
<li>Not easy to expand.</li>
<li>If one system/one link goes down the entire ring will go down.</li>
</ul>
<h3 id="star-topology">Star Topology</h3>
<p>Uses a central hub.</p>
<figure>
<img src="../images/cn/star_topology.png" width="200"
alt="Star Topology" />
<figcaption aria-hidden="true">Star Topology</figcaption>
</figure>
<p><strong>_ Advantages and disadvantages same as of any centralized
system_</strong> Hub can also be expensive.</p>
<h3 id="mesh-topology">Mesh Topology</h3>
<figure>
<img src="../images/cn/mesh_topology.png" width="200" alt="Mesh" />
<figcaption aria-hidden="true">Mesh</figcaption>
</figure>
<p><strong><em>Advantages</em></strong></p>
<ul>
<li>Less traffic</li>
<li>No single point of failure</li>
<li>Messages can be sent directly without any routing</li>
</ul>
<p><strong><em>Disadvantages</em></strong></p>
<ul>
<li>Cabling cost will be higher</li>
<li>Maintenance cost will be higher.</li>
</ul>
<h3 id="tree-topology">Tree Topology</h3>
<p>Tree structure.</p>
<figure>
<img src="../images/cn/tree_topology.png" width="200"
alt="Tree Topology" />
<figcaption aria-hidden="true">Tree Topology</figcaption>
</figure>
<hr />
<h2 id="networks-based-on-geographical-area">Networks Based on
Geographical Area</h2>
<ul>
<li>LAN - Local Area Network</li>
<li>MAN - Metropolitan Area Network</li>
<li>WAN - Wide Area Network</li>
</ul>
<p><strong><em>Differentiate based on cables, cost,
etc.</em></strong></p>
<h2 id="osi-model---open-systems-interconnection">OSI Model - Open
Systems Interconnection</h2>
<p>Given by ISO.</p>
<p>The OSI model is a layered framework for the design of network
systems that allows communication btw all types of computer systems.The
purpose of OSI model is to facilitate communication btw different
systems without requiring changes to the logic of underlying hardware
and software.</p>
<figure>
<img src="../images/cn/osi.jpg" width="400" alt="OSI" />
<figcaption aria-hidden="true">OSI</figcaption>
</figure>
<h3 id="data-in-layers">Data in layers:</h3>
<table>
<colgroup>
<col style="width: 3%" />
<col style="width: 14%" />
<col style="width: 5%" />
<col style="width: 59%" />
<col style="width: 17%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">S.No</th>
<th style="text-align: center;">Layer</th>
<th style="text-align: center;">Data</th>
<th style="text-align: left;">Responsibility</th>
<th style="text-align: left;">Protocols</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">1</td>
<td style="text-align: center;">Application Layer</td>
<td style="text-align: center;">Data</td>
<td style="text-align: left;">To allow access to network resources</td>
<td style="text-align: left;">Telnet, SMTP,DNS, HTTP</td>
</tr>
<tr class="even">
<td style="text-align: center;">2</td>
<td style="text-align: center;">Presentation Layer</td>
<td style="text-align: center;">Data</td>
<td style="text-align: left;">To translate, encrypt and process the
data</td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;">3</td>
<td style="text-align: center;">Session Layer</td>
<td style="text-align: center;">Data</td>
<td style="text-align: left;">To establish, manage and terminate
session</td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: center;">4</td>
<td style="text-align: center;">Transport Layer</td>
<td style="text-align: center;">Segment</td>
<td style="text-align: left;">Process to Process msg delivery, error
recovery</td>
<td style="text-align: left;">TCP, UDP</td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">(Port/Socket Address)</td>
</tr>
<tr class="even">
<td style="text-align: center;">5</td>
<td style="text-align: center;">Network Layer</td>
<td style="text-align: center;">Packet</td>
<td style="text-align: left;">Move packet from source to
destination.</td>
<td style="text-align: left;">IP, ARP, RARP, ICMP</td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">(Logical/IP Address)</td>
</tr>
<tr class="even">
<td style="text-align: center;">6</td>
<td style="text-align: center;">Data Link Layer</td>
<td style="text-align: center;">Frame</td>
<td style="text-align: left;">Hop to hop delivery, organize the
frames</td>
<td style="text-align: left;">IEEE 802 Std., TR,PPP</td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">(Physical/MAC Address)</td>
</tr>
<tr class="even">
<td style="text-align: center;">7</td>
<td style="text-align: center;">Physical Layer</td>
<td style="text-align: center;">Bit</td>
<td style="text-align: left;">Transmit bits over a medium, provide
mechanical and electrical specification</td>
<td style="text-align: left;">Transmission media</td>
</tr>
</tbody>
</table>
<p><strong>ARP</strong> - Address Resolution Protocol - Maps IP to
MAC.</p>
<p><strong>RARP</strong> - Reverse Address Resolution Protocol - Maps
MAC to IP.</p>
<h2 id="physical-layer">Physical Layer</h2>
<p>It is responsible for moving physical bits. It defines:</p>
<ul>
<li>a transmission medium (wireless/wired)</li>
<li>types of encoding to be used</li>
<li>data rate</li>
<li>synchronization of bits</li>
<li>physical topology</li>
</ul>
<h3 id="transmission-media">Transmission Media</h3>
<h4 id="wiredguided-media"><strong>Wired/Guided Media</strong>:</h4>
<ul>
<li><p>Optical Fiber</p>
<figure>
<img src="../images/cn/optical_fibre_transmission.jpeg"
style="width:30.0%" alt="Transmission through Optical Fiber" />
<figcaption aria-hidden="true">Transmission through Optical
Fiber</figcaption>
</figure></li>
<li><p>Coaxial Fiber</p>
<figure>
<img src="../images/cn/Coaxial-Cable.png" style="width:30.0%"
alt="Coaxial Fiber" />
<figcaption aria-hidden="true">Coaxial Fiber</figcaption>
</figure></li>
<li><p>Twisted pair cable</p>
<figure>
<img src="../images/cn/twisted_pair.jpg" style="width:30.0%"
alt="Twisted Pair Cable" />
<figcaption aria-hidden="true">Twisted Pair Cable</figcaption>
</figure></li>
<li><p>Unshielded Twisted Pair (USTC)</p>
<figure>
<img src="../images/cn/ustc.png" style="width:30.0%" alt="USTC" />
<figcaption aria-hidden="true">USTC</figcaption>
</figure></li>
<li><p>Shielded Twisted Pair (STC)</p>
<figure>
<img src="../images/cn/stc.png" style="width:30.0%" alt="STC" />
<figcaption aria-hidden="true">STC</figcaption>
</figure></li>
</ul>
<h4 id="wirelessunguided-media"><strong>Wireless/Unguided
Media</strong>:</h4>
<p>Radio wave, microwave, and infrared</p>
<p>Electromagnetic Spectrum for Wireless Communication</p>
<ul>
<li>3KHz - 300 GHz =&gt; Radio Waves and Microwaves</li>
<li>300Ghz - 400 THz =&gt; Infrared</li>
<li>400 THz - 900 Thz =&gt; Light waves (not used for transmission)</li>
</ul>
<h3 id="propagation-methods">Propagation Methods</h3>
<p>Ground, Sky, Line of Sight</p>
<figure>
<img src="../images/cn/propagation_methods.jpg" width="200"
alt="Propagation Methods" />
<figcaption aria-hidden="true">Propagation Methods</figcaption>
</figure>
<h3 id="bands">Bands</h3>
<table>
<colgroup>
<col style="width: 22%" />
<col style="width: 12%" />
<col style="width: 19%" />
<col style="width: 46%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">Band</th>
<th style="text-align: center;">Range</th>
<th style="text-align: center;">Propagation</th>
<th style="text-align: left;">Application</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">Very Low Freq.</td>
<td style="text-align: center;">3-30 KHz</td>
<td style="text-align: center;">Ground</td>
<td style="text-align: left;">Long range radio navigation</td>
</tr>
<tr class="even">
<td style="text-align: center;">Low Freq.</td>
<td style="text-align: center;">30-300KHz</td>
<td style="text-align: center;">Ground</td>
<td style="text-align: left;">Radio and Navigation Locator</td>
</tr>
<tr class="odd">
<td style="text-align: center;">Medium Freq.</td>
<td style="text-align: center;">300KHz-3MHz</td>
<td style="text-align: center;">Sky</td>
<td style="text-align: left;">AM radio</td>
</tr>
<tr class="even">
<td style="text-align: center;">High Freq</td>
<td style="text-align: center;">3-30 MHz</td>
<td style="text-align: center;">Sky</td>
<td style="text-align: left;">Citizen Band(Ship/Aircraft
Communication)</td>
</tr>
<tr class="odd">
<td style="text-align: center;">Very High Freq.</td>
<td style="text-align: center;">30-300 MHz</td>
<td style="text-align: center;">Sky/Line of Sight</td>
<td style="text-align: left;">Cellular Phone, Satellite</td>
</tr>
<tr class="even">
<td style="text-align: center;">Super high freq.</td>
<td style="text-align: center;">3-30 GHz</td>
<td style="text-align: center;">Line of Sight</td>
<td style="text-align: left;">Satellite Communication</td>
</tr>
<tr class="odd">
<td style="text-align: center;">Extremely high freq.</td>
<td style="text-align: center;">30-300 GHz</td>
<td style="text-align: center;">Line of Sight</td>
<td style="text-align: left;">Radar/Satellite Communication</td>
</tr>
</tbody>
</table>
<p>High Frequencies cannot travel through walls, lower frequencies
can.</p>
<p>High Frequency have less distance, lower frequencies have higher
distance.</p>
<h3 id="switched-networks">Switched Networks</h3>
<p>Large networks cannot have all nodes directly connected with each
other. Therefore, to send data from one node to another, it has to be
sent through other nodes.</p>
<p>Suppose there’s a network with many nodes, and node A wants to send
some data to node B. There are two ways of doing so.</p>
<ol type="1">
<li><p><strong>Packet Switching</strong></p>
<p>Data is divided into small sized packets for transmission. This
increased efficiency, reduces chances of lost data,etc.</p>
<p>1.<strong>Virtual Circuit</strong> - Source establishes a (virtual)
path that the data will follow. Each packet goes through the same
route.</p>
<ol start="2" type="1">
<li><strong>Datagram Switching</strong> - Source doesn’t decide any
route. It sends each packet to the next nodes. Each node can decide
where to forward the packets. Each packet may end up taking a different
route. Packets may be delivered in a different order.</li>
</ol></li>
<li><p><strong>Circuit Switching</strong></p>
<p>A special path is set up for the transmission, and the intermediate
nodes are already decided before the data transmission takes place.
There is a dedicated path set up for the transmission of that
packet.</p></li>
<li><p><strong>Message Switching</strong> - Entire message is
transferred between nodes. Each node stores the message, then decides
where to forward it. This is also called <em>store and
forward</em>.</p></li>
</ol>
<h3 id="network-architecture">Network Architecture</h3>
<p><strong>Protocol</strong> is an agreement between two communicating
parties on how the communication is to take place. Includes things like
format of data, speed, etc.</p>
<p>Networks are organized as a stack of layers. Each layer offers its
services to the layer above it (like OSI). Between each two layers there
is an interface. <strong>Services</strong> are operations a layer
provides to the layer above it. Protocols are used to implement
services.</p>
<p>Set of layers and protocols is called the Network Architecture.</p>
<p>List of Protocols used by a certain system is called <strong>Protocol
Stack</strong>. We generally have one protocol per layer.</p>
<h3 id="types-of-communication-on-the-basis-of-connection">Types of
Communication on the basis of Connection</h3>
<h4 id="connection-oriented">Connection-Oriented</h4>
<ul>
<li>Similar to telephone.</li>
<li>Establish a connection, communicate, and then release the
connection.</li>
</ul>
<h4 id="connectionless">Connectionless</h4>
<ul>
<li>Like postal system</li>
<li>Each packet has the destination address,</li>
<li>Each packet is routed independently through the system.</li>
</ul>
<h2 id="tcpip-stack">TCP/IP Stack</h2>
<h3 id="internet-protocol-ip">Internet Protocol (IP)</h3>
<ul>
<li>Hosts can inject packets into any network.</li>
<li>They will travel to destination independently.</li>
<li>They may arrive out of order.</li>
<li>Connectionless.</li>
<li>Similar to postal service.</li>
</ul>
<h3 id="transmission-control-protocol-tcp">Transmission Control Protocol
(TCP)</h3>
<ul>
<li>Transport Layer</li>
<li>Source and Destination communicate using this.</li>
<li>It is connection-oriented, reliable. Provides no-error
delivery.</li>
<li>Handles flow control</li>
<li>Converts incoming byte-stream (continuous data like video or large
amount of text) into discrete messages. Destination’s TCP reassembles
them.</li>
</ul>
<h3 id="user-datagram-protocol-udp">User Datagram Protocol (UDP)</h3>
<ul>
<li>Transport Layer</li>
<li>Connectionless, unreliable</li>
<li>Faster than TCP.</li>
</ul>
<h2 id="data-link-layer">Data Link Layer</h2>
<h3 id="delay">Delay</h3>
<h4 id="transmission-delay">Transmission Delay</h4>
<p>The delay taken for the host to put the data onto the transmission
line.</p>
<p><span class="math display">\[ T_t = L/B \]</span></p>
<p>where <span class="math inline">\(L\)</span> is the size of the data,
and <span class="math inline">\(B\)</span> is the bandwidth.</p>
<h4 id="propagation-delay">Propagation Delay</h4>
<p>Time taken by the last bit of the data to reach the destination
(after it has been transmitted from host to transmission media at the
source.)</p>
<p><span class="math display">\[ T_p = distance/velocity \]</span></p>
<h4 id="queueing-delay">Queueing Delay</h4>
<p>Each packet waits in the buffer (at destination) before it is
processed. The amount of time it waits is known as the queueing
delay.</p>
<h4 id="processing-delay">Processing Delay</h4>
<p>This is the time taken to process the packet. Includes checking
headers, updating TTL, deciding where to forward it,etc.</p>
<p>Queueing and Processing delays are generally taken to be zero, unless
mentioned otherwise.</p>
<h3 id="framing-techniques">Framing Techniques</h3>
<p>One of the major issue in framing is to decide how to specify the
start and end of a frame.</p>
<p>One way to do this is to use <strong>fixed-size frames</strong>. For
eg, if we say one frame is 50 bytes, then the destination’s data link
layer will know that after the first 50 bytes, the next frame has
begun.</p>
<p>This can lead to wastage of space. If the data in a frame is only 10
bytes, we have to add 40 bytes of empty space.</p>
<p>Thus <strong>variable-sized frames</strong> are more preferred.</p>
<p>Framing techniques for variable-sized frames are given below.</p>
<h4 id="character-count">Character Count</h4>
<p>It involves simply adding the number of characters in a frame to the
data-link header. Before each frame starts, the number of characters in
it is present.</p>
<p>For eg, we have 4 frames with lengths 3,4,2,5 characters
respectively. Our data would look like:</p>
<p><code>(3)(frame1)(4)(frame2)(2)(frame3)(5)(frame4)</code></p>
<p>This isn’t used anymore, because a single bit error in the character
count could lead to miscalculation of frames. Count variable could also
only hold a certain limit of number. For e.g, if <code>count</code> was
specified as an 8-bit number, the maximum value it can hold is <span
class="math inline">\(2^8-1 = 255\)</span>. If our frame has more than
255, we would face issues.</p>
<p>Hence this isn’t used.</p>
<h4 id="flag-character-stuffingbyte-stuffing">Flag (Character
Stuffing/Byte Stuffing)</h4>
<p>We use a special <strong>flag byte</strong> at the start and end of
each frame. It is fixed so it can be recognized.</p>
<p>An issue with this is that the flag byte may occur “accidentally” in
the data itself. This may cause the DLL to assume the frame has ended
even when it has not.</p>
<p>To solve this, we use a special <strong>ESC</strong> byte, which is
also fixed. Accidental flag bytes have the ESC sequence inserted before
them, to tell the DLL that this FLAG is data and not the end of a
frame.</p>
<p>If ESC occurs within the data “accidentally”, we escape it with
another ESC.</p>
<h5 id="examples">Examples</h5>
<p>A Flag B –&gt; A ESC Flag B</p>
<p>A ESC B –&gt; A ESC ESC B</p>
<p>A ESC Flag B –&gt; A ESC ESC ESC Flag B</p>
<p>A ESC ESC B –&gt; A ESC ESC ESC ESC B</p>
<p><strong>Doesn’t work if the data isn’t 8-bit.</strong></p>
<h4 id="bit-stuffing">Bit Stuffing</h4>
<p>A special bit pattern denotes start and end of frames. Generally,
this is taken to be <code>01111110</code>.</p>
<p>If the sender encounters the starting of this pattern in the data, it
adds a 0 or a 1 before it ends so that the pattern never occurs. The
receiver will do the opposite and remove the <em>stuffed</em> 0s or
1s.</p>
<p>For e.g, for <code>01111110</code>,</p>
<p>If the sender encounters a 0 followed by 5 consecutive 1’s, it adds a
0 before continuing. This ensures that <code>01111110</code> never
occurs in the data.</p>
<p>The receiver will <em>destuff</em> these extra zeroes on its end.</p>
<p><code>01111110</code> –&gt; <code>011111010</code></p>
<p><code>011011111111111111110010</code> –&gt;
<code>011011111011111011111010010</code></p>
<h3 id="error-detection-and-control">Error Detection and Control</h3>
<h4 id="parity-check">Parity Check</h4>
<p>Parity check is the simplest method of detecting errors. It involves
using a single check bit after or before the frame.</p>
<p>We count the numbers of 1s and 0s in a particular frame. If it’s odd,
check bit value is 1. If it’s even, check bit value is 0.</p>
<p>101011 - Check bit=0 101001 - Check bit=1</p>
<p>This can only detect single-bit errors. If two bits (a 0 and a 1) are
flipped, the number of 1s remains the same. 2D parity check is more
useful. The data is divided into rows and columns. Parity bit is
calculated for each row and column.</p>
<pre><code>1 0 1 0 1 | 1
1 1 0 0 0 | 0
1 0 1 1 0 | 1
_ _ _ _ _ |
1 1 0 1 1 | 0</code></pre>
<p>The final data becomes</p>
<pre><code>101011
110000
101101
110110</code></pre>
<h4 id="hamming-code">Hamming Code</h4>
<p><strong>Data</strong> - the original data to send</p>
<p><strong>Redundant bits</strong> - bits that aren’t part of the
original data. They have been added for error detection and
correction.</p>
<p><strong>Codeword</strong> - The final result that is sent to the
receiver - combination of data and redundant bits.</p>
<p><strong>Code</strong> is a collection of codewords.</p>
<p><strong>Hamming Distance</strong> between two strings is the number
of positions where the symbols are different. Only valid for strings of
equal length. We will use it for binary numbers.</p>
<p>For eg, hamming distance btw 101 and 100 is 1 (only last bit is
different) btw 101 and 110 is 2 (2nd and 3rd bits are different).</p>
<p><strong>Hamming Distance of a Code</strong> is the minimum hamming
distance between any two codewords in the code.</p>
<p>A code with a hamming distance of <span
class="math inline">\(d\)</span> can <em>detect</em> <span
class="math inline">\(d-1\)</span> bit errors, and <em>correct</em>
<span class="math inline">\(\lfloor (d-1)/2 \rfloor\)</span> errors.</p>
<p>For example, consider a code with the codewords <code>000</code> and
<code>111</code>. The hamming distance of such a code would be 3. We
should be able to detect 2-bit errors, and correct 1-bit errors.</p>
<p>Suppose we were transmitting the codeword <code>000</code> ande
during transmission bit flips occurred:</p>
<ul>
<li><p>If the bit flip resulted in <code>001</code>. We know this is not
a valid codeword (only <code>000</code> and <code>111</code> are valid),
so we know an error has occurred.</p>
<p>The hamming distance between <code>111</code> and <code>001</code> is
2.</p>
<p>The hamming distance between <code>000</code> and <code>001</code> is
1.</p>
<p>Therefore, we can guess that the original word must have been
<code>000</code>. Similarly, we would be able to detect and correct
errors if the bit flip resulted in <code>010</code> or
<code>100</code>.</p></li>
<li><p>If the bit flip resulted in <code>011</code> (2-bit error).</p>
<p>Once again we can see it isn’t a valid codeword, so we are able to
detect the error.</p>
<p>But if we try correcting it, we would think that the original
codeword was <code>111</code>, since the hamming distance of
(<code>111</code>,<code>011</code>) is less than that of
(<code>000</code>,<code>011</code>).</p></li>
<li><p>If the bit flip resulted in <code>111</code> (3-bit error)</p>
<p>We wouldn’t be able to detect the error, since <code>111</code> is a
valid codeword.</p></li>
</ul>
<p>Thus we saw - we can detect 1-bit and 2-bit errors. We can only
correct 1-bit errors.</p>
<p>Hamming Codes can also be used to detect and correct errors in a
different manner.</p>
<p>Let’s say we have data of length <span
class="math inline">\(m\)</span>. First we need to calculate the number
of redundant bits needed to transmit this.</p>
<p><span class="math display">\[ m + r+1 \le 2^r \]</span></p>
<p>The smallest value of <span class="math inline">\(r\)</span>
satisfying this equation can be used as the number of redundant
bits.</p>
<p><strong>Format of the Codeword</strong></p>
<ul>
<li>Total number of bits = <span class="math inline">\(n =
m+r\)</span>.</li>
<li>The bits at positions <span class="math inline">\(2^0, 2^1, 2^2,
2^3...\)</span> and so on are <em>check bits</em>.</li>
<li>The bits in the rest of the positions are data bits.</li>
<li>Bits are numbered from 1.</li>
</ul>
<p><strong>Calculating the values of check bits</strong></p>
<ul>
<li><p>Suppose we have m=7. We can see that r=4 will work. Codeword
length = 7+4=11.</p></li>
<li><p>Bits at positions 1,2,4,8 are check-bits.</p></li>
<li><p>Bits at positions 3,5,6,7,9,10,11 are data bits.</p></li>
</ul>
<p>Suppose our data is 0100110 (7-bit) Final data will look like:</p>
<pre><code>_ _ 0 _ 1 0 0 _ 1  1  0
1 2 3 4 5 6 7 8 9 10 11  </code></pre>
<p>Write the position number of data bits as sum of powers of 2.</p>
<p>3 = 1+2</p>
<p>5 = 1+4</p>
<p>6 = 2+4</p>
<p>7 = 1+2+4</p>
<p>9 = 1+8</p>
<p>10 = 2+8</p>
<p>11 = 1+2+8</p>
<p><strong>To calculate value of check-bit 1:</strong></p>
<ul>
<li>Check which equations have <code>1</code> on the RHS.</li>
<li>Equations for bits 3,5,7 and 9 have <code>1</code> on RHS.</li>
<li>So, we will do a parity count of bits 3,5,7,9</li>
</ul>
<p>Bit 3 = 0</p>
<p>Bit 5 = 1</p>
<p>Bit 7 = 0</p>
<p>Bit 9 = 1</p>
<ul>
<li>Parity count = 0 (even number of 1’s). So, the value of check bit 1
is 0.</li>
</ul>
<p><strong>Value of check bit 2:</strong></p>
<ul>
<li><p>Equations for 3,6,7,10,11 have 2 on RHS.</p></li>
<li><p>Parity count:</p>
<p>Bit 3 -&gt; 0</p>
<p>Bit 6 -&gt; 0</p>
<p>Bit 7 -&gt; 0</p>
<p>Bit 10 -&gt; 1</p>
<p>Bit 11 -&gt; 0</p>
<p>Parity Count = 1</p></li>
<li><p>Value of check bit 2 = 1</p></li>
</ul>
<p>Similarly we can do for check-bit 4 and 8</p>
<p><strong>Check bit 4</strong>:</p>
<p>Equations : 5,6,7 Parity check : 1,0,0 Parity count = 1</p>
<p>Value of check-bit 4=1</p>
<p><strong>Check bit 8</strong></p>
<p>Equations: 9,10,11 Parity Check: 1,1,0 Parity Count = 1</p>
<p>Value of check-bit 8 = 1</p>
<p>Final Codeword:</p>
<pre><code>_ _ 0 _ 1 0 0 _ 1  1  0
1 2 3 4 5 6 7 8 9 10 11

becomes

0 1 0 1 1 0 0 1 1  1  0</code></pre>
<h4 id="checksum">Checksum</h4>
<ul>
<li>Sum all the bits in the data word.</li>
<li>If the checksum goes beyond n bits, add the extra leftmost bits to
the n rightmost bits. (<strong><em>Wrapping</em></strong>)</li>
<li>Take 1’s complement of the sum so found. This becomes our
checksum</li>
<li>Send the checksum along with the data to the receiver.</li>
</ul>
<p>At receiver’s end: - Add all the data received (including the
checksum) - Perform wrapping if necessary. - The end result should be
<code>1111....1</code>, i.e, n times 1 - If the end result is anything
else, it means the data is wrong.</p>
<p><strong>Example</strong></p>
<p>Let n=4. We are sending 4-bit data.</p>
<p>Let the data be 4 numbers : 7,11,12,6.</p>
<ul>
<li>Add all the numbers: 7+11+12+6 = 36</li>
<li>36 cannot be represented in 4-bits, so we perform wrapping.</li>
</ul>
<pre><code>36 in binary 100100

Extra bits are the leftmost 2 bits (10)

Take them and add them to the rightmost 4 bits

0100
  10
----
0110
----

Take 1&#39;s complement

1001
In decimal = 9</code></pre>
<p>9 becomes our checksum which we send to the receiver.</p>
<p>At receiver’s end:</p>
<p>All the data is added.</p>
<p>7+11+12+6+9 = 45</p>
<p>45 cannot be represented in 4-bits, so we will do wrapping</p>
<pre><code>45 in binary is 101101

Take extra digits - leftmost 2 (10)
Add to rightmost 4 

1101
  10
----
1111
----
</code></pre>
<p>We received the sum as 1111, so we know our data is correct.</p>
<h4 id="crc-cyclic-redundancy-check">CRC (Cyclic Redundancy Check)</h4>
<p>Data - k-bit Codeword - n-bit Divisor - (n-k+1) bits. Divisor should
be mutually agreed between sender and receiver.</p>
<ul>
<li>Add (n-k) <code>0</code>s to the dataword.</li>
<li>Divide dataword by divisor using <em>modulo-2 division</em>.</li>
<li>Append the remainder found to the original dataword (without the
extra zeroes)</li>
</ul>
<p>At receiver’s side:</p>
<ul>
<li>Perform modulo-2 division of the received code-word and
divisor.</li>
<li>If the remainder is 0, the data is correct. Otherwise it’s
incorrect.</li>
</ul>
<h5 id="modulo-2-division">Modulo-2 Division</h5>
<p>It’s a method of dividing 2 binary numbers.</p>
<p>It follows the rules and logic of normal division, with subtraction
step replaced by bitwise XOR.</p>
<p><img src="../images/cn/crc.jpg" /></p>
<h3 id="flow-control">Flow Control</h3>
<p>To make sure receiver receives all the data.</p>
<h4 id="stop-wait-arq-automatic-repeat-request">Stop &amp; Wait ARQ
(Automatic Repeat ReQuest)</h4>
<ul>
<li><p>Sender sends a frame and waits for ACK (acknowledgement) for the
frame from receiver.</p></li>
<li><p>Receiver receives the frame. If the frame is correct, receiver
sends ACK.</p></li>
<li><p>If the frame is corrupt, receiver drops the frame and does
nothing.</p></li>
<li><p>Sender waits a certain amount of time for ACK from receiver.
After this, it times out and resends the frame.</p></li>
<li><p>ACK message may also get lost, then the sender will assume the
original frame was corrupted or lost. It will retransmit, which means
the receiver may get duplicate data.</p></li>
<li><p>To avoid this, frames are numbered.</p></li>
<li><p>We only need to differentiate between a frame and its immediate
successor. I.e, we need to differentiate between frame x and x+1. We
don’t need to differentiate between frame x and x+2.</p>
<p>x+2 will never be sent unless both x and x+1 have been sent AND
acknowledged.</p></li>
<li><p>Therefore, 1 bit sequence number is enough. If the first frame is
0, the second frame is 1, the third is again 0, and so on.</p></li>
</ul>
<p><img src="../images/cn/stopandwait.JPEG" /></p>
<h4 id="formulas">Formulas</h4>
<p>Total time taken = Transmission time of data + transmission time of
ACK + propagation time of data + propagation time of ACK + Queuing delay
+ Processing delay.</p>
<p><span class="math display">\[ = T_{t(data)} +
T_{t(ACK)}+T_{P(data)}+T_{P(ACK)} +Delay_{Queue} + Delay_{Processing}
\]</span></p>
<p>We take queue delay and processing delay to be 0. As ACK is very
small, we take transmission time of ACK to be 0.</p>
<p><span class="math display">\[ = T_{t(data)} + T_{P(data)}+T_{P(ACK)}
\]</span></p>
<p>Propagation time of ACK and data will be same.</p>
<p>Total time = <span class="math inline">\(T_t + 2*T_p\)</span></p>
<p>Where <span class="math inline">\(T_t\)</span> is transmission time
of data, and <span class="math inline">\(T_p\)</span> is propagation
time.</p>
<p>Efficiency = <span class="math inline">\(\eta\)</span> = Useful Time/
Total Time</p>
<p><span class="math display">\[ = \frac{T_t}{T_t+2*T_p} \]</span> <span
class="math display">\[ = \frac{1}{1+2(\frac{T_p}{T_t})} \]</span> <span
class="math display">\[ = \frac{1}{1+2a} \]</span></p>
<p>where a = <span class="math inline">\(T_p/T_t\)</span>.</p>
<p>Throughput = <span class="math inline">\(\eta\)</span> *
Bandwidth</p>
<h4 id="go-back-n">Go Back N</h4>
<ul>
<li>Sliding Window Protocol</li>
<li>Receiver window Size = 1</li>
<li>Sender Window Size = <span class="math inline">\(2^m-1\)</span></li>
<li>Sequence numbers for frames – <span
class="math inline">\([0,1,....2^m-1]\)</span>, 0 and <span
class="math inline">\(2^m-1\)</span> inclusive.</li>
<li>Window Size = WS/W</li>
<li>We send up to W frames at a time, and keep them in memory until the
receiver ACKs them.</li>
<li>Receiver only receives one frame at a time.</li>
<li>Receiver can send a single ACK for many frames. For eg if sender
sent 7,8,9 and receiver received all, it can simply send ACK 10.</li>
<li>If receiver receives wrong frame (e.g receiver was waiting for frame
3 and frame 4 came), or a corrupted frame, it stays silent.</li>
<li>Sender’s timer will timeout. Sender will resend all frames in the
window.</li>
</ul>
<p>For e.g, if WS=3 and sender has sent 1,2,3,4,5,6 and timer for 3
times out (1 and 2 ACKed successfully), sender will send 3,4,5
again.</p>
<p>Efficiency = <span class="math inline">\(\eta =
\frac{WS}{1+2a}\)</span></p>
<p>where <span class="math inline">\(a=T_p/T_t\)</span></p>
<p><strong>For maximum efficiency (100% usage),</strong></p>
<ul>
<li><p>WS = 1+2a</p></li>
<li><p>No. of bits needed for sequence number = <span
class="math inline">\(\lceil log(1+2a) \rceil\)</span></p></li>
</ul>
<h4 id="selective-repeat-sr">Selective Repeat (SR)</h4>
<ul>
<li><p>Only lost/corrupted frames are resent.</p></li>
<li><p>Sender window size = Receiver Window Size</p></li>
<li><p>Window Size = <span class="math inline">\(2^m/2\)</span></p></li>
<li><p>Receiver buffers frames that are within its window range. Others
are dropped. For e.g, if receiver’s window is waiting for frames 3,4,5
and sender sends 6, it will be dropped.</p></li>
<li><p>ACK is only sent after frames are received in order. If receiver
window is 3,4,5 and we receive 4,5 - 4,5 will be stored and buffered,
but no ACK will be sent.</p>
<p>Instead, receiver will send a negative acknowledgement (NACK) for 3 -
NACK 3.</p></li>
<li><p>This tells the sender that receiver hasn’t received 3.</p></li>
<li><p>Sender will resend 3 (only 3).</p></li>
<li><p>When 3 is received, receiver will send ACK 6.</p></li>
<li><p>If we had received 3 in the beginning, we would have immediately
sent ACK 4. This would also make the receiver move its window to
4,5,6.</p></li>
</ul>
<p>Example case:</p>
<ul>
<li>Sender window = [3,4,5],6,7. Sender sends 3,4,5.</li>
<li>Receiver receives 3 and sends ACK 4. 4 is lost. Receiver buffers 5
and sends NACK 4. Receiver moves its window by 1 to [4,5,6],7.</li>
<li>As soon as the sender receives ACK 4, it knows receiver has received
3.</li>
<li>It will move its window by 1 to [4,5,6],7. As 5 has already been
sent, sender will now also send 6.</li>
<li>Sender will receive NACK 4 and resend 4.</li>
<li>Receiver will receive 6 from sender, and buffer it. Receiver still
hasn’t received 4. It will send NACK 4.</li>
<li>Receiver will receive 4 from sender. It has 5,6 so it will send ACK
7.</li>
<li>Sender will receive the second NACK and again send 4</li>
<li>Receiver will receive the 4 (that the sender sent earlier), and
accept it. 4,5,6 have all been received. Receiver will send ACK 7, and
move its window to [7,8,9]</li>
<li>Receiver will receive the second 4 sent by the sender. It will be
ignored since it’s out of the window.</li>
<li>Sender will receive ACK 7 and move its window to [7,8,9].</li>
<li>Transmission will continue as normal from here.</li>
</ul>
<figure>
<img src="../images/cn/sr.png" style="width:60.0%"
alt="Selective Repeat Example" />
<figcaption aria-hidden="true">Selective Repeat Example</figcaption>
</figure>
<h4 id="data-encoding-techniques">Data Encoding Techniques</h4>
<h5 id="nrz-unipolar">NRZ-Unipolar</h5>
<p>1 - +ve</p>
<p>0 - 0</p>
<h5 id="nrz-polar">NRZ-Polar</h5>
<p>1 - +ve</p>
<p>0 - -ve</p>
<h5 id="nrz-i">NRZ-I</h5>
<p>Differential Encoding.</p>
<p>1 - Signal transition at start (high-to-low or low-to-high)</p>
<p>0 - No signal transition at start</p>
<h5 id="manchester">Manchester</h5>
<p>Always has a mid-bit transition:</p>
<p>1 - Low to High</p>
<p>0 - High to Low</p>
<p>The start of the bit may also have a transition, if needed according
to the bit’s value.</p>
<p>For eg, if the bit is 1 (which means we need a low to high transition
in the middle), and the interval starts with a high value, we will
transition to low at the start.</p>
<p>(Eg - Encoding 11)</p>
<h5 id="differential-manchester">Differential Manchester</h5>
<p>Mid-bit transition is only for clocking purposes.</p>
<p>1 - Absence of transition at the start.</p>
<p>0 - Presence of transition at the start.</p>
<h5 id="bipolar-encoding">Bipolar Encoding</h5>
<p>1 - Alternating +1/2, -1/2 voltages</p>
<p>0 - 0 voltages</p>
<figure>
<img src="../images/cn/data_encoding.png"
alt="Data Encoding Techniques" />
<figcaption aria-hidden="true">Data Encoding Techniques</figcaption>
</figure>
<h2 id="media-access-sublayer">Media Access Sublayer</h2>
<p>The data link layer is divided into two sublayers.</p>
<ol type="1">
<li><strong>Media Access Control (MAC)</strong> - Defines the access
method for each LAN.</li>
<li><strong>Logical Link Control (LLC)</strong> - Flow control, Error
control, etc.</li>
</ol>
<p>Framing is handled by both.</p>
<h3 id="media-access-control-and-multiple-access-protocols">Media Access
Control and Multiple Access Protocols</h3>
<p>Handle how multiple nodes can communicate on a single link.</p>
<h3 id="random-access-contention-methods">Random Access/ Contention
Methods</h3>
<ul>
<li>All nodes are considered equal.</li>
<li>No scheduled transmission.</li>
<li>Transmission occurs randomly.</li>
<li>Nodes compete for access.</li>
</ul>
<h4 id="pure-aloha">Pure Aloha</h4>
<ul>
<li><p>Each node sends a frame when it has a frame to send.</p></li>
<li><p>Obviously, we will have collisions in case 2 nodes decide to send
a frame together.</p></li>
<li><p>Aloha expects the receiver of the frame to send ACK for the
frame.</p></li>
<li><p>Vulnerable time for Aloha is <span
class="math inline">\(2*T_t\)</span>. This is the time frame in which
collisions can happen.</p>
<p>For eg, A sent a frame at 12:05</p>
<p>Let transmission time = 5 minutes.</p>
<p>B wants to send a frame. But it cannot send a frame until 12:10,
because till 12:10 A will be transmitting its frame. A collision will
occur if B sends before 12:10.</p>
<p>Similarly, if C had earlier sent a frame anytime after 12:00, A’s
frame will collide with it.</p>
<p>Therefore, the vulnerable time is 12:00 - 12:10, which is 10 minutes
= twice of transmission time.</p></li>
<li><p>In case a collision occurs, the node waits a random amount of
time before retransmitting. How much time to wait is explained in the
flowchart below.</p></li>
<li><p>Maximum number of attempts are fixed.This value is called <span
class="math inline">\(K_{max}\)</span> For eg, if max attempts = 15, if
a node has transmitted the same frame 15 times and always gotten
collision, it will abort and try again some time later.</p></li>
<li><p><span class="math inline">\(K_{max}\)</span> is generally set to
be 15.</p></li>
</ul>
<p><strong>Efficiency of Pure Aloha</strong> <span
class="math display">\[ S = G.e^{-2G} \]</span></p>
<p>where <span class="math inline">\(G\)</span> is the the average
number of frames created by the <em>entire system</em> (all nodes
combined), during the transition time of a single frame.</p>
<p>For eg, if <span class="math inline">\(T_t\)</span> is 1ms, G is
number of frames produced per millisecond.</p>
<p><span class="math inline">\(S_{max}=0.184\)</span> at <span
class="math inline">\(G=1/2\)</span>.</p>
<figure>
<img src="../images/cn/aloha.png" alt="Flowchart for Aloha" />
<figcaption aria-hidden="true">Flowchart for Aloha</figcaption>
</figure>
<p>The procedure of choosing a random number between 0 and <span
class="math inline">\(2^K-1\)</span>, incrementing the value of K, and
waiting an amount of time based on R, is called the <strong>backoff
procedure.</strong></p>
<h4 id="slotted-aloha">Slotted Aloha</h4>
<ul>
<li>Same as Aloha, but time is divided into slots.</li>
<li>Time is discrete and globally synced (all nodes have same value of
time)</li>
<li>Frames can be sent <em>only at the beginning</em> of a time
slot.</li>
<li>Vulnerable Time = <span class="math inline">\(T_t\)</span></li>
</ul>
<p><strong>Efficiency of Slotted Aloha</strong> <span
class="math display">\[ S = G.e^{-G} \]</span></p>
<p><span class="math inline">\(S_{max}=0.368\)</span> at <span
class="math inline">\(G=1\)</span>.</p>
<h4 id="csma-carrier-sense-multiple-access">CSMA (Carrier Sense Multiple
Access)</h4>
<ul>
<li>Each node will sense the medium before sending.</li>
<li>If the medium is idle, send the data. Otherwise wait.</li>
<li>Collisions may still occur due to propagation delay.</li>
</ul>
<p>For e.g, if A sent a frame at 12:01, and propagation time from A to D
is 2 minutes. If D checks the medium at 12:02, it will find it idle and
send the frame. A’s frame and D’s frame will then collide.</p>
<ul>
<li>Vulnerable time = <span class="math inline">\(T_p\)</span> (Max
propagation time).</li>
</ul>
<h4 id="persistence-methods-for-csma">Persistence Methods for CSMA</h4>
<p>Persistence methods decide when and how to send data after sensing
medium.</p>
<h5 id="persistent">1-Persistent</h5>
<ul>
<li>Continuously Sense the medium.</li>
<li>As soon as the medium is idle, send the data immediately.</li>
</ul>
<h5 id="non-persistent">Non-Persistent</h5>
<ol type="1">
<li>If medium is idle, send the data immediately.</li>
<li>If medium busy, wait a random amount of time, then sense the medium
again and repeat from step 1.</li>
</ol>
<ul>
<li>Less efficient, as the channel may remain idle in the random waiting
time.</li>
<li>Less chance of collision.</li>
</ul>
<h5 id="p-persistent">P-Persistent</h5>
<p>Uses a value <span class="math inline">\(p\)</span> that is fixed by
the network administrator for each node. Different nodes have different
values of <span class="math inline">\(p\)</span> 1. Continuously check
medium till idle. 2. If idle: - Generate random number <span
class="math inline">\(r\)</span> - If <span
class="math inline">\(r&lt;p\)</span>, then transmit the data. - Else: -
Wait for a time slot, and then check the line. - If line is idle, go to
step 2. - If the line is busy, act as if a collision occurred, and
follow the backoff procedure.</p>
<h4 id="csma-with-collision-detection-csmacd">CSMA with Collision
Detection (CSMA/CD)</h4>
<ul>
<li>Continue sensing medium for time= <span
class="math inline">\(2*T_p\)</span> after transmission.</li>
<li>This will help us sense potential collisions.</li>
<li>If a collision is detected, the node that detected the collision
will send a jamming signal to the access medium. After that, backoff
procedure will be applied.</li>
<li>Condition to detect collision: <span class="math display">\[
T_t=2*T_p \]</span> The transmission time for the frame should be long
enough that we can detect collisions while we are transmitting it.</li>
<li>Efficiency of CSMA/CD is<span class="math display">\[\eta =
\frac{1}{1+6.44a}\]</span> where <span
class="math inline">\(a=T_p/T_t\)</span>.</li>
</ul>
<h2 id="network-layer">Network Layer</h2>
<ul>
<li>Moves packet from source to destination</li>
<li>Uses routers, bridges, switches.</li>
<li>Deals with IP addresses.</li>
</ul>
<p>Performs the following functions:</p>
<ul>
<li>Routing</li>
<li>Fragmentation</li>
<li>Congestion Control</li>
</ul>
<p>IP addresses have two parts - network ID, and host ID. Network ID
represents which network the IP address is part of, i.e, which
organization controls it. Host ID represents which <em>computer</em> (or
mobile,printer,etc.) in that network the IP address belongs to.</p>
<p>For e.g, Google has many servers. They will all have the same Network
ID, but different Host IDs.</p>
<h3 id="classful-addressing">Classful Addressing</h3>
<p>IPv4 addresses were divided into various classes for easier
addressing purposes.</p>
<p>An IPv4 address is a 32-bit address. For ease of representation, it
is divided into 4 octets. Each octet contains 8-bits.</p>
<p>(8)(8)(8)(8)</p>
<p>It allows us to write the IP address in the following format -
192.168.10.1 Here, 192 is the first octet, 168 is the second, and so on.
All are represented in decimal. This is called Dotted Decimal
Representation.</p>
<h4 id="class-a">Class A</h4>
<p>In this, the first bit of the first octet is always fixed as 0.</p>
<pre><code>0 _ _ _ _ _ _ _ . (octet 2) . (octet 3) . (octet 4)</code></pre>
<p>The range of the first octet becomes <code>00000000</code> to
<code>01111111</code>, i.e. 0 to 127.</p>
<p>The 1st octet represents the Network ID (7-bits).</p>
<p>The 2nd, 3rd and 4th octet represent the Host ID (24-bits).</p>
<p><strong>Number of IP Addresses in Class A</strong> = <span
class="math inline">\(2^{31}\)</span>, which is half of all IPv4
Addresses in the world.</p>
<p><strong>Total number of Networks</strong> = <span
class="math inline">\(2^7-2 = 126\)</span>. Range is [1,126].</p>
<p>The network IDs 00000000 and 01111111 are reserved and unused. They
aren’t given to any organization.</p>
<p><strong>Total number of hosts in each Network</strong> = <span
class="math inline">\(2^{24}-2\)</span></p>
<p>Host with values 0.0.0 and 255.255.255 (first and last hosts) are
also reserved and unused.</p>
<p>The host with value 0.0.0 is used to represent the entire network.
So, for a network with networkID = 28, 28.0.0.0 is used to represent the
entire network (and not any particular host in the network).</p>
<p>Host with value 255.255.255 is used to represent Direct Broadcast
Address. If anyone wants to send a particular message to <em>all</em>
the hosts in a network, they will use this. For a network with networkID
=28, 28.255.255.255 represents its direct broadcast address.</p>
<p><strong>Default Mask</strong> for class A is 255.0.0.0</p>
<p><strong>For any IP address, performing bitwise AND of the IP Address,
and the Default Mask for its class will give us the network that IP
address belongs to</strong>.</p>
<p>For eg, let the IP address be 28.12.34.1</p>
<p>First bit of first octet is 0, so we know it’s a class A Address.</p>
<p>Bitwise AND with 255.0.0.0</p>
<pre><code>00011100.00001100.00100010.00000001 (28.12.34.1)
11111111.00000000.00000000.00000000
-----------------------------------
00011100.00000000.00000000.00000000

= 28.0.0.0</code></pre>
<p>28.0.0.0 represents the network that the IP address 28.12.34.1
belongs to.</p>
<hr />
<h4 id="class-b">Class B</h4>
<p>First octet has first 2 bits fixed as <code>10</code></p>
<pre><code>1 0 _ _ _ _ _ _ . (octet 2) . (octet 3) . (octet 4)</code></pre>
<p>First 2 octets represent the Network ID.</p>
<p>Last 2 octets represent the Host ID.</p>
<p><strong>Range</strong> is (128-191)</p>
<p><strong>Number of IP Addresses</strong> = <span
class="math inline">\(2^{30}\)</span>, 25% of all IPv4 addresses in the
world.</p>
<p><strong>Number of networks</strong> = <span
class="math inline">\(2^{14}\)</span></p>
<p><strong>Number of hosts in each network</strong> = <span
class="math inline">\(2^{16}-2 = 65534\)</span></p>
<p>First and last hosts are excluded here, as they were in class A.</p>
<p><strong><em>Class A excluded first and last networks also. Class B
excludes first and last hosts only. All networks in Class B are
available for use.</em></strong></p>
<p><strong>Default Mask</strong> - 255.255.0.0.</p>
<hr />
<h4 id="class-c">Class C</h4>
<p>First octet has first 3 bits fixed as <code>110</code></p>
<pre><code>1 1 0 _ _ _ _ _ . (octet 2) . (octet 3) . (octet 4)</code></pre>
<p>First 3 octets represent the Network ID.</p>
<p>Last octet represent the Host ID.</p>
<p><strong>Range</strong> is (192-223)</p>
<p><strong>Number of IP Addresses</strong> = <span
class="math inline">\(2^{29}\)</span>, 12.5% of all IPv4 addresses in
the world.</p>
<p><strong>Number of networks</strong> = <span
class="math inline">\(2^{21}\)</span></p>
<p><strong>Number of hosts in each network</strong> = <span
class="math inline">\(2^8-2 = 254\)</span></p>
<p>First and last hosts are excluded here, as they were in class A.</p>
<p><strong><em>Class A excluded first and last networks also. Class C
excludes first and last hosts only. All networks in Class C are
available for use.</em></strong></p>
<p><strong>Default Mask</strong> - 255.255.255.0.</p>
<h4 id="class-d">Class D</h4>
<p>First Octet has first 4 bits reserved as <code>1110</code></p>
<pre><code>1 1 1 0 _ _ _ _ . (octet 2) . (octet 3) . (octet 4)</code></pre>
<p><strong>Range</strong> is (224-239)</p>
<p><strong>Number of IP Addresses</strong> = <span
class="math inline">\(2^{28}\)</span></p>
<p>In class D, all IP addresses are reserved. There is no network ID and
no host ID.</p>
<p>These IP addresses are only meant to be used for multicasting, group
email, broadcasting, etc.</p>
<hr />
<h4 id="class-e">Class E</h4>
<p>First Octet has first 4 bits reserved as <code>1111</code></p>
<pre><code>1 1 1 1 _ _ _ _ . (octet 2) . (octet 3) . (octet 4)</code></pre>
<p><strong>Range</strong> is (240-255)</p>
<p><strong>Number of IP Addresses</strong> = <span
class="math inline">\(2^{28}\)</span></p>
<p>All IP addresses are reserved for military purposes.</p>
<hr />
<h3 id="classless-addressing">Classless Addressing</h3>
<p>This divides 32-bit IP addresses into BlockID and HostID.</p>
<p>BlockID is similar to NetworkID.</p>
<p><strong>Format</strong> - x.y.z.w/n</p>
<p><span class="math inline">\(n\)</span> represents the number of bits
used to represent the blockID.</p>
<p>It also represents the number of 1-bits that the mask for this IP
address should have.</p>
<p>For e.g - 128.225.1.1/10</p>
<p>This means the first 10 bits represent the block ID, and rest 22 bits
specify host ID.</p>
<p>The mask for this network would be -
<code>11111111.11000000.00000000.00000000</code>, (10 times 1, then all
0)</p>
<p>To find the network, we do bitwise AND of IP address and mask</p>
<pre><code>10000000.11100001.00000001.00000001
11111111.11000000.00000000.00000000
-----------------------------------
10000000.11000000.00000000.00000000

= 128.192.0.0</code></pre>
<p>The network that IP address belongs to is 128.192.0.0/10</p>
<h4 id="rules-for-classless-addressing">Rules for Classless
Addressing</h4>
<ul>
<li><p>Addresses should be contiguous</p></li>
<li><p>Number of addresses must be in power of 2.</p></li>
<li><p>1st address of every block must be evenly divisible by block size
(number of hosts)</p>
<p>Block Size = number of hosts = <span
class="math inline">\(2^{32-10}=2^22\)</span> First address of block is
same as network’s IP address = 128.192.0.0/10 =
10000000.11000000.00000000.00000000 =
10000000110000000000000000000000</p>
<p>We don’t need to divide. We can just check that the last 22 (22 is
number of bits used to specify host) bits are 0.</p>
<p>i.e, the 22 least significant bits (LSBs) should be 0, which is true
in our case.</p></li>
</ul>
<h3 id="subnetting">Subnetting</h3>
<p>Subnetting is the process of dividing a large network into smaller
<em>subnets</em>. This helps in organization, security, fixing bugs,
etc.</p>
<p>An organization may divide it’s network into separate subnets for
finance department, legal department, etc.</p>
<p>We do this by dividing the hosts.</p>
<p><strong><em>NetworkID REMAINS UNCHANGED IN SUBNETTING,
ALWAYS.</em></strong></p>
<h4 id="subnetting-in-classful-addressing">Subnetting in Classful
Addressing</h4>
<p>Suppose we have a network with the IP <code>200.10.20.0</code>. This
is a Class C IP address.</p>
<p>It has a total of 254 hosts. We want to divide it into 2 equal
subnets.</p>
<ul>
<li>Network ID is 200.10.20. This will remain unchanged.</li>
<li>The last octet is used to specify the host. Let’s say we want 2
subnets - <span class="math inline">\(S_1\)</span> and <span
class="math inline">\(S_2\)</span>.</li>
<li>We will subnet by fixing the first bit in the last octet as either 1
or 0.</li>
</ul>
<h5 id="s_1"><span class="math inline">\(S_1\)</span></h5>
<p>For the last octet, we will prefix the first bit for <span
class="math inline">\(S_1\)</span> as <code>1</code>.</p>
<p><span class="math inline">\(S_1\)</span> will have IP addresses of
the form <code>200.10.20.1 _ _ _ _ _ _ _</code>.</p>
<p><strong>Range</strong> =&gt; 200.10.20.128 - 200.10.20.255</p>
<p><strong>Usable IP addresses</strong> = <span
class="math inline">\(2^7-2 = 126\)</span></p>
<p><strong>Network IP address</strong> for <span
class="math inline">\(S_1\)</span> is 200.10.20.128.</p>
<p><strong>Broadcast IP address</strong> is 200.10.20.255</p>
<h5 id="s_2"><span class="math inline">\(S_2\)</span></h5>
<p>For the last octet, we will prefix the first bit for <span
class="math inline">\(S_2\)</span> as <code>0</code>.</p>
<p><span class="math inline">\(S_2\)</span> will have IP addresses of
the form <code>200.10.20.0 _ _ _ _ _ _ _</code>.</p>
<p><strong>Range</strong> =&gt; 200.10.20.0 - 200.10.20.127</p>
<p><strong>Usable IP addresses</strong> = <span
class="math inline">\(2^7-2 = 126\)</span></p>
<p><strong>Network IP address</strong> for <span
class="math inline">\(S_1\)</span> is 200.10.20.0.</p>
<p><strong>Broadcast IP address</strong> is 200.10.20.127</p>
<p>Thus, if the network receives a packet meant for 200.10.20.50, it
will be sent to <span class="math inline">\(S_2\)</span>.</p>
<p>A packet meant for 200.10.20.165 will be sent to <span
class="math inline">\(S_1\)</span>.</p>
<h5 id="subnet-mask">Subnet Mask</h5>
<p>Since we are indirectly using 1 extra bit to specify Network ID now,
our subnet mask will also have 1 extra bit added to it.</p>
<p>Class C’s Subnet mask is 255.255.255.0</p>
<p>Now, it will be <code>255.255.255.1 _ _ _ _ _ _ _</code>.</p>
<p>We added 1 in the place where we prefixed an extra bit.</p>
<p>Subnet mask for our network is now 255.255.255.128</p>
<hr />
<p>Our total number of usable IP addresses has become 126+126= 252.
Earlier, it was 254.</p>
<p>Due to subnetting, we have lost the use of 2 IP addresses.</p>
<p><strong>Number of usable IP addresses</strong> = Number Of Original
Usable IP Addresses - <span class="math inline">\(n*2\)</span></p>
<p>where <span class="math inline">\(n\)</span> is the number of
subnets.</p>
<h4 id="subnetting-in-classless-addressing">Subnetting in Classless
Addressing</h4>
<p>The procedure is mostly the same as for subnetting in classful
addressing. The only extra thing that needs to be done is to change the
value of <span class="math inline">\(n\)</span>.</p>
<p>For.eg,</p>
<p>128.192.0.0/10 - let this be our network.</p>
<p>First 10 bits specify block. Last 22 bits specify host.</p>
<p><strong>10000000.11</strong>000000.00000000.00000000. The bold part
represents block ID.</p>
<p>To subnet into two equal subnets, we fix the first host-bit.</p>
<p>Subnet 1 will have IP addresses of the form 10000000.111<em>0</em>_ _
_ _ ._ _ _ _ _ _ _ _ ._ _ _ _ _ _ _ _. (We prefixed 0)</p>
<p>Subnet 2 will have IP addresses of the form 10000000.111<em>1</em>_ _
_ _ ._ _ _ _ _ _ _ _ ._ _ _ _ _ _ _ _. (We prefixed 1)</p>
<p>To find out IP Addresses for Subnet1 and Subnet2, we will have to
increase the value of <span class="math inline">\(n\)</span> by 1, since
now we are using an extra bit to find out block ID.</p>
<p><strong>Subnet1 IP Address</strong> = 128.192.0.0/11</p>
<p><strong>Subnet2 IP Address</strong> = 128.224.0.0/11</p>
<p>Accordingly, mask will be changed.</p>
<h4 id="variable-length-subnet-masking-vlsm">Variable Length Subnet
Masking (VLSM)</h4>
<p>In case we want subnets of different sizes, we use this technique. It
works for both classless and classful addressing in similar ways. We’ll
explain using classful here.</p>
<p>Suppose we have a network with IP 200.10.20.0.</p>
<p>We want to divide it into 3 networks - <span
class="math inline">\(S_1,S_2,S_3\)</span>. <span
class="math inline">\(S_1\)</span> should have 50% of all hosts. <span
class="math inline">\(S_2\)</span> and <span
class="math inline">\(S_3\)</span> should have 25% each.</p>
<p>We will subnet in the following way:</p>
<h5 id="s_1-1"><span class="math inline">\(S_1\)</span></h5>
<p><strong>IP Addresses of the form</strong> - 200.10.20.0 _ _ _ _ _ _ _
(1 bit prefixed)</p>
<p><strong>Range</strong> - 200.10.20.0 - 200.10.20.127</p>
<p><strong>Usable IP Addresses</strong> - 126</p>
<h5 id="s_2-1"><span class="math inline">\(S_2\)</span></h5>
<p><strong>IP Addresses of the form</strong> - 200.10.20.1 0 _ _ _ _ _ _
(2 bits prefixed)</p>
<p><strong>Range</strong> - 200.10.20.128 - 200.10.20.191</p>
<p><strong>Usable IP Addresses</strong> - 62</p>
<h5 id="s_3"><span class="math inline">\(S_3\)</span></h5>
<p><strong>IP Addresses of the form</strong> - 200.10.20.1 1 _ _ _ _ _ _
(2 bits prefixed)</p>
<p><strong>Range</strong> - 200.10.20.192 - 200.10.20.255</p>
<p><strong>Usable IP Addresses</strong> - 62</p>
<p>For <span class="math inline">\(S_1\)</span>, we prefixed only 1 bit.
For <span class="math inline">\(S_2\)</span> and <span
class="math inline">\(S_3\)</span> we prefixed two bits. We can see that
the <span class="math inline">\(S_1\)</span> has roughly double the
number of IP addresses that <span class="math inline">\(S_2\)</span> and
<span class="math inline">\(S_3\)</span> each have.</p>
<p>We divided the network into two equal halves - <span
class="math inline">\(S_1\)</span>, and let’s call the other part <span
class="math inline">\(S&#39;\)</span>.</p>
<p>Then, we further divided <span class="math inline">\(S&#39;\)</span>
into <span class="math inline">\(S_2\)</span> and <span
class="math inline">\(S_3\)</span>.</p>
<figure>
<img src="../images/cn/subnet.png" alt="VLSM" />
<figcaption aria-hidden="true">VLSM</figcaption>
</figure>
<h3 id="header-formats-for-ip-protocols">Header Formats for IP
Protocols</h3>
<p>Whenever a packet is sent using IP (IPv4 or IPv6), it includes data
(payload), as well as a header. The header doesn’t contain the actual
data, but it contains metadata such as destination, priority, source,
etc.</p>
<h4 id="ipv4-header-format">IPv4 Header Format</h4>
<ul>
<li>IPv4 is a <a href="#connectionless">connectionless</a> <a
href="#switched-networks">datagram</a> service.</li>
<li>Header size is between 20-60 bytes.</li>
<li>The total datagram size is at max 64 KB, or 65535 bytes.</li>
<li>The payload size is maximum 65515 bytes. This happens when the
header size is 20 bytes. In case the header size is larger than 20, the
max payload size will be decreased accordingly.</li>
</ul>
<figure>
<img src="../images/cn/ipv4.png" alt="IPv4 Header Format" />
<figcaption aria-hidden="true">IPv4 Header Format</figcaption>
</figure>
<h5 id="ver">VER</h5>
<ul>
<li><p>Stands for version. It is a 4-bit value. It contains the value of
version, i.e, which IP version is being used.</p></li>
<li><p>Almost all transmissions either use IPv4 or IPv6.</p></li>
<li><p>Version for IPv4 is 4 = 0100</p></li>
<li><p>Version for IPv6 is 6 = 0110</p></li>
</ul>
<h5 id="hlen">HLEN</h5>
<ul>
<li>Contains the header-length.</li>
<li>4-bit value.</li>
<li>Uses a factor of 4.</li>
</ul>
<p>Header size = HLEN*4.</p>
<p>As the minimum header size for IPv4 is 20 bytes, HLEN can never be
0,1,2,3 or 4.</p>
<h5 id="type-of-service">Type of Service</h5>
<ul>
<li>Also known as DSCP (Differentiated Service Code Point)</li>
<li>8-bit value</li>
<li>Contains different values specifying the type of service we wish to
use.</li>
</ul>
<p>The 8 bits are:</p>
<p><code>[P][P][P][D][T][R][C][0]</code></p>
<p>The first 3 bits (P) are used to set the precedence, or priority of
the packet.</p>
<p><em>D - Delay.</em></p>
<p>0 means normal delay. 1 tells router this packet needs minimal
delay.</p>
<p><em>T- Throughput</em></p>
<p>0 - normal</p>
<p>1 - maximize</p>
<p><em>R - Reliability</em></p>
<p>0 - normal</p>
<p>1 - maximize</p>
<p><em>C - Cost</em></p>
<p>0 - normal</p>
<p>1 - minimize</p>
<p>The last value is reserved as 0. It’s fixed for future use. Only one
bit out of D,T,R and C can be 1 in a packet. More than 1 cannot be 1.
For eg - 0011 is not valid.</p>
<h5 id="total-length">Total Length</h5>
<p>Contains total length of the packet. 16-bit value.</p>
<h5 id="ttl-time-to-live">TTL (Time to Live)</h5>
<ul>
<li>8-bit value</li>
<li>Source sets it to max value (255), or it can also be set as (max
number of routers between source and destination)*2.</li>
<li>At each node it encounters (router/switch/etc.), the value is
reduced by 1.</li>
<li>When it becomes 0, the packet is dropped.</li>
<li>This helps in case a packet is getting stuck in loops in the
network, causing congestion.</li>
</ul>
<h5 id="protocol">Protocol</h5>
<ul>
<li>8-bit</li>
<li>Tells which protocol is being used, TCP,UDP, etc.</li>
</ul>
<h5 id="header-checksum">Header Checksum</h5>
<ul>
<li>Contains the checksum value for the header.</li>
<li>16-bit</li>
<li>Only IP header fields are used while calculating checksum, actual
data isn’t used. This is because higher level protocols such as TCP and
UDP use their own checksums for the data, so it isn’t required for IP to
do it as well.</li>
<li>Since fields like TTL can change, header checksum is recalculated at
each router.</li>
</ul>
<h5 id="source-ip">Source IP</h5>
<ul>
<li>Contains IP address of the source</li>
<li>32-bit</li>
</ul>
<h5 id="destination-ip">Destination IP</h5>
<ul>
<li>Contains IP address of destination.</li>
<li>32-bit</li>
</ul>
<hr />
<p>Fragmentation is done for packets that are larger in size than the
permitted size.</p>
<p>The packet is broken down into many smaller packets, then sent over
the network. It is reassembled at the source.</p>
<p>The IPv4 header contains values to identify the fragments.</p>
<h5 id="identification-bits">Identification Bits</h5>
<p>This is a 16-bit unique packet ID. It identifies a group of fragments
that belong to a single IP datagram.</p>
<h5 id="flag">Flag</h5>
<p>3-bit value.</p>
<p><code>[R][D][M]</code></p>
<p>The first bit is reserved as 0.</p>
<p>The second bit (D) stands for <strong>Do not Fragment</strong>. If
this bit is 1, no node will try to fragment this bit. But, if some node
doesn’t allow a packet of a large size, and we set D=1, the node may
drop that packet altogether.</p>
<p>The third bit (M) stands for <strong>More Fragments</strong></p>
<p>If M=0, either this packet is the last packet in its datagram, ot
it’s the only fragment.</p>
<p>If M=1, it means more fragments are coming after this packet.</p>
<h5 id="fragment-offset">Fragment Offset</h5>
<p>This represents the number of data bytes ahead of this particular
fragment, i.e, the position of this fragment in the original
unfragmented datagram.</p>
<p>It uses a factor of 8.</p>
<p>I.e, number of bytes ahead = Fragment Offset * 8.</p>
<p>For eg, if a datagram is broken into 4 fragments of 80 bytes each
(excluding the header length).</p>
<p>Fragment offset value for</p>
<p>1st fragment - 0 (No bytes ahead of it)</p>
<p>2nd fragment - 10 (80 bytes of data ahead of it. 80/8=10)</p>
<p>3rd fragment - 20</p>
<p>4th fragment - 30</p>
<h5 id="options">Options</h5>
<p>These contain optional headers and metadata. For example, they may
be:</p>
<h6 id="record-route">Record Route</h6>
<p>Tells the nodes to record the route this packet has taken in the
header. Can record upto 9 router addresses.</p>
<h6 id="source-routing">Source routing</h6>
<p>The source defines the route that the packet will take.</p>
<p>It is of two types.</p>
<ol type="1">
<li>Strict - The source defines the exact specific nodes the packet will
travel through to get to its destination. Each router mentioned in the
list <em>must</em> be visited, and routers that are absent in the list
<em>must not</em> be visited.</li>
<li>Loose - The source defines only loose requirements. Routers in the
list <em>must</em> be visited, but the packet can also visit other
routers.</li>
</ol>
<p>Users cannot set source routing, only routers are allowed to do
this.</p>
<h6 id="padding">Padding</h6>
<p>This is added in case the header size is not in multiple of 4.</p>
<p>We need to store the header length in HLEN, which uses a factor of
4.</p>
<p>So, if the header length is 21, we will add 3 bytes of padding to
make it 24. Then HLEN will store 24/4 = 6.</p>
<h4 id="ipv6-header">IPv6 Header</h4>
<ul>
<li>IPv6 uses 128-bit IP addresses instead of 32-bit.</li>
<li>Only source can fragment packets. Intermediate nodes cannot.</li>
<li>Header length is fixed at 40 bytes.</li>
</ul>
<figure>
<img src="../images/cn/ipv6.png"
alt="IPv6 Header. Length of fields written in brackets." />
<figcaption aria-hidden="true">IPv6 Header. Length of fields written in
brackets.</figcaption>
</figure>
<p><strong>VER</strong> is the same as in IPv4.</p>
<p><strong>Traffic Type</strong> is the same as Type of Service in
IPv4.</p>
<h5 id="flow-label">Flow Label</h5>
<p>20-bit value.</p>
<p>For continuous data that travels in a flow, such as video streaming,
or live updates, we use flow labels. Even large files may be sent using
flows.</p>
<p>Intermediate routers use source IP, destination IP and flow label to
distinguish one flow from another. A source and a destination may have
multiple flows occurring between them.</p>
<p>For e.g, if you’re downloading two files together from Google Drive,
they may be sent through 2 different flows.</p>
<p>So, we give them different flow labels to help identify which flow is
which.</p>
<h5 id="payload-length">Payload Length</h5>
<p>Length of the payload</p>
<h5 id="next-header">Next Header</h5>
<p>IPv6 uses extension headers instead of options. Metadata for routing,
authentication, fragmentation, etc. are set in special extension
headers.</p>
<p>This field is a 8-bit field that contains the type of the extension
header (if present), that comes immediately after the IPv6 header. Each
extension header contains its own “Next Header” field. The extension
headers are thus chained together like this.</p>
<p><img src="../images/cn/ipv6next.png" /></p>
<p>In some cases, this field is also used to indicate protocols in upper
layers, such as TCP or UDP.</p>
<h5 id="hop-limit">Hop Limit</h5>
<p>Same as TTL in IPv4 Header</p>
<p><strong>Source IP</strong> and <strong>Destination IP</strong> are
128-bit IPv6 addresses for the source and destination respectively.</p>
<h5 id="extension-headers">Extension Headers</h5>
<p>Extension headers may be used for many purposes. Some common
extension headers used in IPv6 are:</p>
<ul>
<li>Routing headers, used if source wants to determine the route the
packet should take.</li>
<li>Authentication headers, used for security purposes.</li>
<li>Fragmentation Header, used for fragments.</li>
<li>Destination options - For data that we want only the destination to
open, no intermediate routers</li>
<li>Hop by Hop options, used to specify delivery parameters at each hop
on the path to the destination.</li>
</ul>
<hr />
<h3 id="congestion-control">Congestion Control</h3>
<p>Congestion Control deals with preventing the entire <em>network</em>
from having too much data transmitting at once. Even if every single
node is transmitting within their individual limits, the combined flow
of data may congest the network.</p>
<p>Two main algorithms for Congestion Control are used - Leaky Bucket
and Token Bucket.</p>
<h4 id="leaky-bucket">Leaky Bucket</h4>
<p>This algorithm simulates a leaky bucket, which is usually implemented
as a queue. The bucket has an incoming stream of water (data) that can
have different speeds. There is a hole in the bottom of the bucket that
is our output stream, which “leaks” water at a constant rate, even if
the incoming stream is faster than it.</p>
<p>This ensures that even if the host is sending a lot of data together,
the network is not congested with it. It is usually implemented as a
FIFO queue with a fixed output rate.</p>
<p>If the bucket/queue is full, and more data arrives from the host, it
will “overflow”,i.e, be lost.</p>
<p>A drawback is that this fixes a rigid pattern at the output, no
matter what the pattern of the input is. This is fixed by the token
bucket approach.</p>
<h4 id="token-bucket">Token Bucket</h4>
<p>In this, tokens are added to the bucket at a constant rate. When a
packet arrives, it takes the corresponding amount of tokens in the
bucket, and is transmitted. For example, to transmit 1MB data, we need
1MB of tokens.</p>
<p>If the bucket doesn’t have 1MB of tokens, the packet must wait, or be
discarded. If the bucket has &gt;= 1MB of tokens, the packet will take
as many as it needs (1MB), and be transmitted.</p>
<p>If the bucket is full, no more tokens are added (i.e, incoming tokens
are discarded.)</p>
<h3 id="routing-protocols">Routing Protocols</h3>
<p>Routing Protocols are used to decide the route a particular packet
will take to its destination.</p>
<h4 id="distance-vector-routing-dvr">Distance Vector Routing (DVR)</h4>
<ul>
<li>Each node maintains table of minimum distance to <em>every</em>
other node in the network.</li>
<li>Table also contains <em>next</em> entry for each node. I.e, if we
have node A’s table, that contains data about node B,C,D… etc. If
<em>next</em> value for B is C, that means to get to B from A, we go
through node C.</li>
<li>Information is shared only between neighbors (directly connected).
Each node will share its routing table to its immediate neighbours.</li>
<li>Update may be <strong>periodic</strong> or
<strong>triggered</strong>.</li>
<li>Count to Infinity problem may occur in this.
<ul>
<li>Three nodes - X—A—B. X-A = 1, A-B=1, X-A=2</li>
<li>If link between X and A breaks, then the following problem will
occur. A will set its distance to X as infinity.</li>
<li>B will send its routing table to A. A will think B has found another
path to X with cost 2. It will update its routing table so that
X-A=2+1=3</li>
<li>A will send new table to B. B will think the cost to get to X
(through A) has increased to 3. It will update its table so that
X-B=4.</li>
<li>Similarly, B will again send the new table to A. A will update the
X-A value to 5. This process will continue forever.</li>
</ul></li>
<li><strong>Split Horizon</strong> technique is used to solve count to
infinity.
<ul>
<li>If B knows optimum route to X is through A, it will not send X-B
value to A.</li>
<li>Taking information from A, and sending it back to A, is what causes
the loop.’</li>
<li>A will update the X-A value to infinity. B will send the routing
table to A (but without the X-B) value. A will not update anything and
send the new routing table to B. B will change the X-B value to
infinity.</li>
</ul></li>
<li>Bellman Ford is used to calculate distance tables.</li>
</ul>
<h4 id="link-state-routing">Link State Routing</h4>
<ul>
<li>Router sends information about its neighbors to the entire network
through flooding.</li>
<li>Uses Dijsktra to calculate routing tables.</li>
<li>Hello messages are sent to discover neighbor nodes.</li>
</ul>
<h4 id="routing-in-subnets">Routing in Subnets</h4>
<p>When a data packet arrives at a network that has subnets:</p>
<ul>
<li>The router will perform bitwise <em>AND</em> of the destination IP
in the packet, with all the subnet masks in the network.</li>
<li>The result of the <em>AND</em> operation will be checked in the
routing table.</li>
<li>In case we find a single match in the table, we will send that
packet to the corresponding interface.</li>
<li>In case we find more than one match, we will send it to the
interface with the longest <em>subnet mask</em></li>
<li>In case we don’t find any match, we send it to the default
interface.</li>
<li>In fixed length subnetting all subnets have the same mask, so we
perform bitwise <em>AND</em> only once.</li>
</ul>
<h3 id="network-protocols">Network Protocols</h3>
<h4 id="arp-address-resolution-protocol">ARP (Address Resolution
Protocol)</h4>
<ul>
<li>Each device (computer, phone, printer,etc.) on a network has an IP
Address as well as a MAC Address.</li>
<li>The IP Address identifies the device on the network. The MAC Address
is the physical address of the device.</li>
</ul>
<p><strong>ARP</strong> maps a device’s IP Addresses (Logical Address)
to its MAC Address.</p>
<p><strong>RARP</strong> (Reverse Address Resolution Protocol) maps MAC
Address</p>
<ul>
<li>If A wants to send a packet to B that is on the same network, it
needs the link-layer address (physical or MAC address) in order to send
it over the link.</li>
<li>A will only know B’s IP address, not MAC address. It sends an ARP
request.</li>
<li>ARP request is a broadcast that is sent to all devices on the
network. The request contains
<ul>
<li>A’s IP address</li>
<li>A’s MAC address</li>
<li>B’s IP address</li>
</ul></li>
<li>The ARP request will be ignored by all nodes except B. B will
recognize it’s IP address in the request and it will send an ARP
response packet back to A. The response packet will contain B’s IP and
MAC addresses. The response packet will be sent <em>only to A</em>, as a
unicast.</li>
</ul>
<h4 id="nat-network-address-translation">NAT (Network Address
Translation)</h4>
<ul>
<li>Translates Public IP to Private IP, and vice-versa.</li>
<li>Due to lack of IPv4 addresses, we separated an organization’s public
IP from its private IP.</li>
</ul>
<p>For e.g, an organization has 100 different computers, that all need
to connect to the Internet. Instead of giving them 100 public IPs, we
give the organization a single public IP.</p>
<p>Each of the 100 hosts is then given a <em>private</em> IP.</p>
<p>For example:</p>
<p><strong>Organization’s Public IP</strong> - 192.20.20.0</p>
<p><strong>Private IPs in the Organization</strong> - 10.0.0.1,
10.0.0.2, 10.0.03, etc.</p>
<p>We attach a NAT (Network Address Translator) to the organization’s
network. Generally this is part of the router.</p>
<p>NAT translators will translate a private IP to a public IP, so that
the computer can access the Internet, or other networks. It can send
data to the Internet, and receive data from the Internet.</p>
<p>When sending data, the NAT will translate private IP to public IP.
When receiving data, it will translate public to private IP. Different
port numbers may be used to identify different computers.</p>
<h2 id="transport-layer">Transport Layer</h2>
<h3 id="responsibilities">Responsibilities</h3>
<ul>
<li><p><strong>Port to Port Delivery/ Process to Process
Delivery.</strong> It must deliver the data from the sender application
(for e.g, a browser) to the receiver application (the server of the
website the user opened).</p></li>
<li><p><strong>Segmentation</strong> - Break down the data into smaller
parts that can be sent over the network, and reassemble it at the
receiver side.</p></li>
<li><p><strong>Multiplexing and Demultiplexing</strong> - A single
device generally only has a single connection to the Internet (or any
other network). If multiple applications are using that connection,
multiplexing and demultiplexing of data is done.</p></li>
<li><p><strong>Connection Management</strong></p></li>
<li><p><strong>Reliability</strong> - All the data must be delivered to
the receiver correctly. No lost/corrupted data should be delivered.
Lost/corrupted data must be detected and resent. <strong>UDP doesn’t
provide reliability.</strong></p></li>
<li><p><strong>Order</strong> - Data must be sent in order. If the data
was broken down into 4 parts, they must arrive in the correct order.</p>
<p>It is possible that the network layer sends them out of order - for
e.g, 2,3,1,4. The Transport layer must correct the order before
delivering the complete data to the Application Layer. <strong>UDP
doesn’t provide in-order delivery.</strong></p></li>
<li><p><strong>Error Control</strong> - Checksums are used for this.
Receiver verifies the checksum that the sender sent.</p></li>
<li><p><strong>Congestion Control</strong></p></li>
<li><p><strong>Flow Control</strong></p></li>
</ul>
<h3 id="socket-address-and-port-numbers">Socket Address and Port
Numbers</h3>
<p>Socket Addresses are made up of an IP address, and a 16-bit port
number. They are used to uniquely identify a TCP/UDP/ any other
transport layer protocol connection.</p>
<p>A particular computer will have an IP address, but many applications
running on it may need to access the Internet. When data packets arrive,
the OS must be able to figure out which data packet belongs to which
application.</p>
<p>A unique port number is assigned to each application. Only one
application may use a particular port at a given time. For e.g, two
applications cannot listen on port 3000 at the same time.</p>
<h4 id="port-number-types">Port Number Types</h4>
<p>There are three categories of port numbers:</p>
<ol type="1">
<li><p><strong>Well Known/System Ports</strong> - These are the ports
for most commonly used networking tasks. For example, a web-server will
always listen for HTTP requests on Port 80, and HTTPS on port 443. An
email server will always listen on port 25 for SMTP (Simple Mail
Transfer Protocol) requests. Assigning fixed numbers makes it easier to
handle common tasks. Typing www.google.com in a browser is the same as
typing www.google.com:443, because the browser knows that the standard
port for HTTPS is 443.</p>
<p>Range for these is 0-1023.</p></li>
<li><p><strong>Registered/User Ports</strong> - Organizations and
Applications can have specific ports reserved for their use. They can
register these with IANA (Internet Assigned Numbers Authority). For e.g,
Xbox Live has 3074 port number reserved for it.</p>
<p>Range for these is 1025-49151.</p></li>
<li><p><strong>Dynamic/Ephemeral Ports</strong> - These are the rest of
the ports left in the range. When an application needs to use a
transport layer protocol, it requires a port number. The OS will
generally assign it any random port number that is currently not in
use.</p>
<p>Range for these is 49152-65535</p></li>
</ol>
<p>Registered, and even well-known ports can be used for other tasks.
For example, you can still run an email server on Port 80. You can also
use Port 3074 for something other than Xbox Live. These are simply
guidelines and standards to prevent confusion and clashes.</p>
<p><strong><em>IP Address is used to differentiate one machine from
another. Port Numbers are used to differentiate different applications
on the same machine.</em></strong></p>
<h4 id="section"></h4>
<h3 id="tcp-transmission-control-protocol">TCP (Transmission Control
Protocol)</h3>
<p>TCP (Transmission Control Protocol) is a popular transport layer
protocol. Most applications, such as HTTP, HTTPS, Email (SMTP/IMAP),
etc. use TCP.</p>
<h4 id="characteristics">Characteristics</h4>
<p>Characteristics of TCP are:</p>
<ol type="1">
<li><strong>Byte Streaming</strong> - Application layer continuously
sends data to the transport layer. TCP breaks it down into bytes, and
packages several bytes into a single <strong>segment</strong>. Multiple
segments are created and sent to the receiver.</li>
<li><strong>Connection-Oriented</strong> - TCP establishes a connection
with the receiver first, using a 3-way handshake. All future
communication between sender and receiver occurs over this
connection.</li>
<li><strong>Full Duplex</strong> - Two-way communication can happen, at
the same time.</li>
<li><strong>Piggybacking</strong> - Sender sends data to receiver, and
receiver must send back acknowledgement for that data. In most cases
these days, communication occurs both ways, i.e, if A sends data to B, B
also sends data to A. Thus, instead of B sending acknowledgements
separately to A, B will attach the acknowledgement along with the data
it has to send A.
<ol type="1">
<li><strong>Needs buffers</strong> - Sending and receiving processes may
not operate at same speed, therefore TCP needs sender and receiver
buffers for storage.</li>
</ol></li>
</ol>
<h4 id="tcp-header">TCP Header</h4>
<figure>
<img src="../images/cn/tcpheader.jpg" alt="TCP Header" />
<figcaption aria-hidden="true">TCP Header</figcaption>
</figure>
<p>TCP Header is attached to each TCP Segment. It contains the following
fields. It’s size can vary from 20-60 bytes.</p>
<h5 id="source-port">Source Port</h5>
<p>Port Number for the source (sender) application.</p>
<h5 id="destination-port">Destination Port</h5>
<p>Port Number for the destination (receiver) application.</p>
<h5 id="sequence-number">Sequence Number</h5>
<p>Each segment is given a sequence number based on the data sent before
it. When a TCP connection is established, a random sequence number is
generated.</p>
<p>For e.g, let the initial sequence number be 500. (For now, ignore the
increase in sequence number during the 3-way handshake)</p>
<p>Let’s say A sends B 200 bytes of data, in 4 segments of size 50
bytes. The sequence number will be 500 for the first segment, 550 for
the second segment, 600 for the third, and so on.</p>
<h5 id="acknowledgment-number">Acknowledgment Number</h5>
<p>This is used to let the sender know that the packet that it sent has
been received. It is set as the value of the next sequence number that
the receiver is expecting.</p>
<p>For e.g, if A sends B data with sequence number 500, that has 50
bytes in it. Thus, B receives bytes number 500,501,502….549. Now, it
expects byte number 550. Thus, it will set Acknowledgement Number as
550.</p>
<h5 id="header-lengthdata-offset">Header Length/Data Offset</h5>
<p>Length of the TCP Header. Uses a factor of 4, same as <a
href="#hlen">IPv4 Header’s HLEN field</a></p>
<h5 id="reserved">Reserved</h5>
<p>Next 6 bits are reserved for future use. 2 of them have already been
defined as CWR and ECE.</p>
<h5 id="code-bitsflag-bits">Code-Bits/Flag Bits</h5>
<p>There are 6 Flag Bits, each with their own purpose.</p>
<h6 id="urg-urgent">URG (Urgent)</h6>
<p>If this bit is set to 1, it means that this segment contains urgent
data. Location of the urgent data is set in the <a
href="#urgent-field">urgent pointer</a>.</p>
<h6 id="ack">ACK</h6>
<p>Indicates that this message contains an acknowledgement, i.e, the
value of the <a href="#acknowledgment-number">acknowledgement number</a>
is significant.</p>
<h6 id="psh-push">PSH (Push)</h6>
<p>When receiver is receiving data, it will generally buffer some amount
of data before sending it to the application layer. PSH field indicates
that the receiver should stop buffering and push whatever data it has to
the application layer.</p>
<h6 id="rst-reset">RST (Reset)</h6>
<p>Used to Reset the TCP connection.</p>
<h6 id="syn-sync">SYN (Sync)</h6>
<p>Used to sync sequence numbers. Only the first packet sent from each
end should have this value set.</p>
<h6 id="fin-finish">FIN (Finish)</h6>
<p>Used to terminate the connection.</p>
<h5 id="window-size">Window Size</h5>
<p>Specifies the size of the receiver’s window, i.e, the current amount
of data it is willing to receive. A will tell its window size to B, and
B will tell its window size to A.</p>
<h5 id="checksum-1">Checksum</h5>
<p>Used for error-checking.</p>
<h5 id="urgent-field">Urgent Field</h5>
<p>If the segment contains urgent data, this field tells <em>where</em>
the urgent data is located. It contains the sequence number of the
<em>last</em> urgent byte. For eg, if A sent bytes number 500-549, and
bytes 500-520 are urgent, the urgent field will contain the value
520.</p>
<h5 id="options-1">Options</h5>
<p>Contains optional fields, such as timestamps, window scale, and
<strong>maximum segment size (MSS)</strong>. MSS is the maximum size of
<strong>one</strong> single segment that the receiver is willing to
accept. It is separate from window size, which may be larger, as a
window can contain multiple segments.</p>
<h5 id="padding-1">Padding</h5>
<p>In case the total header size is not a multiple of 4, we add empty
zeroes to make it so, so that we can store it in the <a
href="#header-length/data-offset">header length</a> field.</p>
<h4 id="tcp-connection-establishment">TCP Connection Establishment</h4>
<p>A 3-way handshake is used to establish a TCP connection. This process
occurs before any actual data is sent. The 3 steps are:</p>
<ol type="1">
<li><p><strong>SYN</strong> - Sender will send the receiver a connection
request. It will send a randomly generated sequence number,its port
number, its window size, etc. It will set the SYN flag as 1, indicating
that it wants to set up a connection.</p>
<p>Let’s say A sent a connection request to B, with the sequence number
3000 (random), and window size as 1200 bytes. This will let B know that
A only can only receive 1200 bytes of data (until it empties its buffer
again)</p></li>
<li><p><strong>SYN-ACK</strong> - The receiver will respond to the
sender’s request. It will send a response, with SYN field as 1. It will
also send an acknowledgement (in the same response), and tell its own
window size to the sender.</p>
<p>B will reply to A. It will generate a random sequence number, say
5000. It will set the ACK and SYN flag. It will also set the
acknowledgement number to 3001 (since A’s sequence number was 3000.) It
sends A its window size, say 800 bytes.</p></li>
<li><p><strong>ACK</strong> - Sender will acknowledge the response.
After this, sender and receiver will begin exchanging actual data. SYN
flag is 0 in this.</p>
<p>A will send B a response with sequence number 3001, and
Acknowledgment number 5001. ACK will be set as 1. SYN flag will be
0.</p></li>
</ol>
<blockquote>
<p>Sequence numbers are not consumed if PURE ACK is sent. If a segment
contains only ACK, and not data, and it uses sequence number <span
class="math inline">\(x\)</span>, then the next segment can also use
sequence number <span class="math inline">\(x\)</span>.</p>
</blockquote>
<p>After this, A and B can start exchanging data. Both A and B will
reserve some resources (memory, RAM, etc.) for this A-B TCP
connection.</p>
<p>A will not send more than 800 bytes to B, and B will not send more
than 1200 bytes to A. A will send sequence numbers 3002,3003,3004…., and
B will send sequence numbers 5001,5002,5003… and so on.</p>
<h4 id="tcp-connection-termination">TCP Connection Termination</h4>
<p>4-way handshake.</p>
<ol type="1">
<li><p><strong>FIN from Client</strong>- Client wants to close the
connection. Client will send server a segment with FIN bit as 1. (Server
may also choose to close the connection)</p>
<p>Client will enter <strong>FIN_WAIT_1</strong> state. In this state,
the client waits for an ACK from the server for this FIN segment. This
is also called <strong>Active Close</strong> state.</p></li>
<li><p><strong>ACK From Server</strong>- Server will receive the FIN
segment, and send an ACK to the client. Server now enters a
<strong>Close Wait (Passive Close)</strong> state. Server will release
any buffer resources, because client has said it doesn’t want to send
any more data to server. (Server may still have data to send to the
client).</p>
<p>When the client receives the ACK from server, it enters
<strong>FIN_WAIT_2</strong> state. In this state, the client is waiting
for the server to send a segment with FIN bit set as 1 (i.e, client is
waiting for server to also close the connection.)</p></li>
<li><p><strong>FIN from Server</strong> - Server can send any pending
data, and then it will send a segment with FIN bit as 1. Server now
enters <strong>LAST_ACK</strong> state. In this state, the server only
expects to receive one last ACK from the client (for the FIN segment
server just sent). After receiving the ACK, Server will release all
resources for this connection, and the connection will be
closed.</p></li>
<li><p><strong>ACK from Client</strong> - Client will receive the
server’s FIN segment, and send an ACK for it. Client will enter
<strong>TIME_WAIT</strong> state. In this, the client waits in case the
final ACK was lost. If the final ACK was lost, the server will timeout
and resend the FIN message. If the client receives any FIN message in
the <strong>TIME_WAIT</strong> state, it will resend the ACK. If it
doesn’t, client assumes the last ACK was successfully delivered, and it
will close the connection.</p>
<p>The amount of time to be waited varies, but it’s generally 30s or 1
min.</p></li>
</ol>
<figure>
<img src="../images/cn/tcp_state_diagram" alt="TCP State Diagram" />
<figcaption aria-hidden="true">TCP State Diagram</figcaption>
</figure>
<p>Dashed lines are for server, solid for client.</p>
<h4 id="tcp-congestion-control">TCP Congestion Control</h4>
<p>Congestion Window is used for congestion control. Size of congestion
window changes throughout the TCP connection. We first increase it, to
send more data in less time. In case congestion occurs while increasing,
we again decrease it.</p>
<p>Concept of MSS (Maximum Segment Size) is used.</p>
<p>Congestion Control in TCP has 3 phases:</p>
<ol type="1">
<li><p><strong>Slow Start Phase (Exponential Growth)</strong> - In this,
the congestion window is increased exponentially. Initially, the window
size is 1 MSS. Then it becomes 2 MSS, then 4, then 8, then 16, and so
on, until the <em>slow start threshold</em>. Slow Start Threshold is
determined as <span class="math display">\[
(Receiver Window Size/MSS)/2
\]</span> This gives max number of segments in slow start phase (not
their size.)</p></li>
<li><p><strong>Congestion Avoidance Phase (Linear Growth)</strong> -
Congestion Window grows linearly. If it at <span
class="math inline">\(x\)</span> MSS , it becomes <span
class="math inline">\(x+1\)</span>, then <span
class="math inline">\(x+2\)</span>, and so on.</p>
<p>This continues until congestion window size becomes equal to receiver
window size. After that, we keep congestion window size as
constant.</p></li>
<li><p><strong>Congestion Detection</strong> - Congestion is detected in
this phase, and we change window size to accommodate it.</p>
<p>There are two ways in which congestion can be detected:</p>
<ol type="1">
<li><p><strong>Time-Out</strong> - When timer times out before we
receive an ACK. Congestion in this case is Severe.</p></li>
<li><p><strong>3-ACK</strong>- Sender receives 3 duplicate ACKs for the
same segment. Congestion in this case is light.</p>
<p>For e.g, if sender sent packets 1,2,3,4 and 5. Receiver received
packet 1 and sent ACK 2 (Original ACK). Packet 2 was lost. Receiver
received packet 3, and again sent ACK 2 (because it hasn’t received
packet 2). Receiver received packet 4, and again sent ACK 2. Similarly
for packet 5. Sender will thus receive 4 ACKS - 1 original, and 3
duplicate acknowledgments for packet 2.</p></li>
</ol></li>
</ol>
<h5 id="reaction-in-congestion-detection">Reaction in Congestion
Detection</h5>
<h6 id="time-out">Time-Out</h6>
<ol type="1">
<li>Slow Start Threshold is set as half of current window size. For e.g,
if current window size is 16 MSS, slow start threshold will be 8.</li>
<li>Congestion window is reset to be equal to 1 MSS.</li>
<li>Slow Start Phase is resumed</li>
</ol>
<h6 id="ack-1">3-ACK</h6>
<ol type="1">
<li>Slow Start Threshold is set as half of current window size.</li>
<li>Congestion window is set equal to slow start threshold</li>
<li>Congestion Avoidance phase is resumed</li>
</ol>
<h4 id="wrap-around">Wrap-Around</h4>
<ul>
<li>TCP Sequence numbers go from 0 to <span
class="math inline">\(2^{32}\)</span> .</li>
<li>This doesn’t mean only 4GB (<span
class="math inline">\(2^{32}\)</span> bytes) of data can be sent</li>
<li>After all the sequence numbers are used, and more data needs to be
sent, sequence numbers can be wrapped around and used from starting</li>
<li>Time taken to use all the <span
class="math inline">\(2^{32}\)</span> numbers is called <strong><em>wrap
around time</em></strong></li>
</ul>
<p><strong><em>Wrap Around Time =</em></strong> <span
class="math inline">\(\frac{2^{32}}{bandwidth}\)</span></p>
<p><strong>Life Time</strong> of a TCP Segment is 3 minutes or 180
seconds, i.e, a receiver will have to wait max 3 minutes before it
receives a segment</p>
<ul>
<li>if WAT &gt; LT, no issue</li>
<li>if LT&gt; WAT, then receiver can receive multiple segments with same
sequence number. To solve this, additional fields like timestamp are
used.</li>
</ul>
<h4 id="tcp-window-scaling">TCP Window Scaling</h4>
<ul>
<li><p>TCP Window Size field is 16-bit, which means the window can only
be <span class="math inline">\(2^{16}\)</span> bits, or 64KB.</p></li>
<li><p>This is generally too less for modern applications</p></li>
<li><p>Using the options headers in TCP, we can specify a scaling
factor. For e.g, if scaling factor is 3, and the window size is
specified as 400, then the actual window size will be <span
class="math inline">\(400*2^3 = 3200\)</span>.</p>
<p>i.e, <span class="math display">\[ WS_{real} =
WS_{field\_value}*2^{scale\_factor}\]</span></p></li>
<li><p>Generally, this is allowed when the <strong>bandwidth delay
product</strong> is greater than 64KB.</p>
<p>Bandwidth Delay Product = Bandwidth * RTT</p></li>
<li><p>Maximum value of scaling factor is 14, i.e, the max window size
becomes <span class="math inline">\(2^{16} * 2^{14} = 2^{30} =
1GB\)</span></p></li>
</ul>
<p>Sender Window in TCP is calculated using both Receiver Window Size
and Congestion Window Size. It is chosen as the minimum of both. Sender
window size being larger than either of those will result in TCP
retransmission.</p>
<h4 id="tcp-timers">TCP Timers</h4>
<h5 id="retransmission-timer">Retransmission Timer</h5>
<ul>
<li>TCP start timer after each transmission. If an ACK is not received
before this timer runs out, the segment is retransmitted.</li>
<li>The amount of time it waits is called RTO (Retransmission
Timeout)</li>
<li>RTO is calculated using RTT, there are many ways to do so.</li>
</ul>
<h6 id="measured-rtt-rtt_m">Measured RTT (<span
class="math inline">\(RTT_m\)</span>)</h6>
<p>This is the direct measured value of how long it takes for a packet
being sent and for its ACK to be received.</p>
<h6 id="smoothed-rtt-rtt_s">Smoothed RTT (<span
class="math inline">\(RTT_s\)</span>)</h6>
<p>It is the weighted average of measured RTT, since <span
class="math inline">\(RTT_m\)</span> can fluctuate.</p>
<p>It is calculated as:</p>
<p>After the first measurement, <span class="math inline">\(RTT_s =
RTT_m\)</span></p>
<p>After each measurement, <span class="math inline">\(RTT_s =
(1-t)*RTT_s + t*RTT_m\)</span></p>
<p>where <span class="math inline">\(t=1/8\)</span> , unless specified.
<span class="math inline">\(t\)</span> is also sometimes written as
<span class="math inline">\(\alpha\)</span></p>
<p><strong>RTO</strong> can be then kept as <span
class="math inline">\(2*RTT_s\)</span></p>
<h6 id="deviated-rtt-rtt_d">Deviated RTT (<span
class="math inline">\(RTT_d\)</span>)</h6>
<p>It is calculated as:</p>
<p>After the first measurement, <span class="math inline">\(RTT_d =
RTT_m/2\)</span></p>
<p>After each measurement, <span class="math inline">\(RTT_s =
(1-k)*RTT_s + k*(RTT_m-RTT_s)\)</span></p>
<p>where <span class="math inline">\(k=1/4\)</span> , unless specified.
<span class="math inline">\(k\)</span> is also sometimes written as
<span class="math inline">\(\beta\)</span></p>
<p><strong>RTO</strong> is then calculated as <span
class="math inline">\(RTT_s+4*RTT_d\)</span></p>
<h5 id="time-wait-timer">Time-Wait Timer</h5>
<ul>
<li>Takes care of late packets</li>
<li>Never close a TCP connection immediately. Wait for 2*LT, so that any
delayed packets can arrive.</li>
</ul>
<h5 id="keep-alive-timer">Keep-Alive Timer</h5>
<ul>
<li>Used to close idle connections.</li>
<li>Periodically check connections, and close them if no reply.</li>
<li>After keep-alive time duration, server will send 10 probe messages
with gap of 75 seconds. If no reply, the connection is closed.</li>
<li>Keep-alive time duration is generally 2 hours.</li>
</ul>
<h5 id="persistent-timer">Persistent Timer</h5>
<ul>
<li>Suppose receiver’s buffer is full, so it sends an ACK to sender with
window-size=0</li>
<li>Sender understands that it cannot send more data as receiver buffer
is full, and it waits.</li>
<li>Receiver processes the data in buffer and empties it. Now it has
space, so it sends another ACK to server with window-size = some
non-zero value. Suppose this ACK gets lost.</li>
<li>Now, sender is waiting for receiver to empty its buffer, and
receiver is waiting for sender to send data. This is a
<strong>deadlock</strong>.</li>
<li>To prevent this, persistent timer is use. When sender receives a
packet with window size=0, it will start a persistent timer.</li>
<li>After that timer goes off, it will send a probe with only 1 byte of
new data. The receiver will receive this probe and send its new window
size.</li>
<li>If the new window size is non-zero, the sender will start
transmitting data. If it is still zero, the sender will start the
persistent timer again and wait.</li>
</ul>
<h3 id="udp">UDP</h3>
<p>UDP (User Datagram Protocol) is another transport layer service. It’s
popular applications include DNS, VoIP, etc.</p>
<h4 id="characteristics-1">Characteristics</h4>
<ul>
<li>Connectionless</li>
<li>Unreliable</li>
<li>Messages may be delivered out of order.</li>
<li>Less overhead, as header is very small.</li>
<li>Faster than TCP.</li>
</ul>
<h4 id="header">Header</h4>
<figure>
<img src="../images/cn/udp-header.png" alt="UDP Header" />
<figcaption aria-hidden="true">UDP Header</figcaption>
</figure>
<ul>
<li>Header size is fixed at 8 bytes.</li>
<li>Length contains total length (header+data)</li>
<li>Maximum length of UDP datagram is <span
class="math inline">\(2^{16}\)</span> bytes (including header)</li>
<li>Checksum field is optional in IPv4, mandatory in IPv6.</li>
</ul>
<h4 id="udp-applications">UDP Applications</h4>
<ul>
<li><strong>Query-Response Protocol</strong> (One query-One reply, no
need to make a connection as we only need one reply). For e.g - DNS</li>
<li><strong>Speed</strong> - When we need high-speed applications. For
e.g. - Online games, VoIP.</li>
<li><strong>Broadcasting/Multicasting</strong>- Eg, RIP (Routing
Information Protocol), Distance Vector Routing. Nodes share routing
tables after every 30 seconds, to <em>all other nodes</em>. If we use
TCP, the node will have to establish connections with all other nodes,
which will be time consuming.</li>
<li><strong>Continuous Streaming</strong>- E.g, Skype/YouTube.</li>
<li><strong>Stateless</strong> - Don’t save information about the
connecting clients.</li>
</ul>
<h3 id="tcp-vs-udp">TCP vs UDP</h3>
<table>
<colgroup>
<col style="width: 46%" />
<col style="width: 53%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">TCP</th>
<th style="text-align: center;">UDP</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">Connection-Oriented</td>
<td style="text-align: center;">Connectionless</td>
</tr>
<tr class="even">
<td style="text-align: center;">Reliable</td>
<td style="text-align: center;">Unreliable</td>
</tr>
<tr class="odd">
<td style="text-align: center;">In-order Delivery</td>
<td style="text-align: center;">Delivery may be out of order</td>
</tr>
<tr class="even">
<td style="text-align: center;">Error Control is Mandatory</td>
<td style="text-align: center;">Error control is optional</td>
</tr>
<tr class="odd">
<td style="text-align: center;">Slow</td>
<td style="text-align: center;">Fast</td>
</tr>
<tr class="even">
<td style="text-align: center;">More Overhead</td>
<td style="text-align: center;">Less overhead</td>
</tr>
<tr class="odd">
<td style="text-align: center;">Flow Control, Congestion Control</td>
<td style="text-align: center;">No flow control or congestion
control</td>
</tr>
<tr class="even">
<td style="text-align: center;">HTTP, FTP</td>
<td style="text-align: center;">DNS,BOOTP,DHCP</td>
</tr>
</tbody>
</table>
<h2 id="application-layer">Application Layer</h2>
<p>Enables users (human or s/w) to access the network. It is responsible
for providing services to the user.</p>
<h3 id="paradigms">Paradigms</h3>
<ul>
<li>Provides services to the user</li>
<li>To use the internet we need 2 application programs that communicate
with each other using the application layer.</li>
<li>Communication uses a logical connection, i.e, the 2 application
programs assume that there is an imaginary direct connection between
them. In reality, the communication happens through various layers
(Transport, Network, Data-Link, etc.)</li>
</ul>
<p>There are 2 types:</p>
<ul>
<li><strong>Client-Server</strong> - Server program provides service to
the client program. It is the most popular method today. Server runs
continuously. Client creates a connection to the server using the
Internet and requests a particular service.</li>
<li><strong>Peer to Peer</strong> - Gaining popularity in recent times.
Both communicating programs have equal responsibility and power. No
program needs to be always running. A computer can even provide and
receive services at the same time.</li>
</ul>
<h3 id="file-transferring">File Transferring</h3>
<h4 id="ftp-file-transfer-protocol">FTP (File Transfer Protocol)</h4>
<ul>
<li>It’s an application layer protocol used for transferring (uploading
and downloading) files over the Internet.</li>
<li>It uses TCP under the hood.</li>
<li>It solves problems such as different systems having different ways
of representing and storing files.</li>
<li>It establishes 2 connections between 2 hosts:
<ul>
<li>One connection is used for control information (commands and
responses). This uses TCP port 21. It remains active during the FTP
session.</li>
<li>The other connection is used for actual data transfer. This uses TCP
port 20. It closes and opens for each file transfer.</li>
</ul></li>
</ul>
<h5 id="security-in-ftp">Security in FTP</h5>
<ul>
<li>Security was not a big issue when FTP was created.</li>
<li>FTP supports passwords, but they are sent unencrypted, therefore
they can be intercepted.</li>
<li>Data is also transferred unencrypted.</li>
<li>SSL (Secure Sockets Layer) can be added to FTP (between FTP and TCP)
to make it more secure. This makes it SSL-FTP.</li>
</ul>
<h4 id="ftam-file-transfer-access-management">FTAM (File Transfer Access
Management)</h4>
<ul>
<li>FTP was created by the Internet standard. FTAM is the OSI
counterpart to FTP.</li>
<li>It is a Application Layer protocol that provides access and
management to a <em>distributed</em> network file system.</li>
<li>It allows users to access file systems both locally and
remotely.</li>
<li>It defines an architecture for a hierarchical file system. Any file
system that wants to be accessible using FTAM must follow this
architecture.</li>
<li>It does not define or create a user interface for accessing such
file systems. Vendors and users can create their own based on the
architecture specified.</li>
<li>It is more similar to Gopher or WWW rather than FTP. FTP only allows
files, whereas FTAM also allows links to other FTAM directories (like
WWW does)</li>
</ul>
<h3 id="email">Email</h3>
<ul>
<li>Used to send messages over the Internet</li>
<li>Used to be plain text, now can include images, videos, files,
etc.</li>
<li>Actual message transfer is done using a message transfer agent
(MTA). Client must have client MTA to send mail, server must have server
MTA to receive mail.</li>
</ul>
<h4 id="smtp">SMTP</h4>
<p>SMTP (Simple Mail Transfer Protocol) is the formal protocol that
defines MTA client and server applications. SMTP defines how commands
and responses must be sent back and forth. It is used twice, once
between sender and sender’s mail server, and second between sender’s
mail server and receiver’s mail server. Mail is transferred in 3 phases
- Connection Establishment, Mail Transfer, and Connection
Termination.</p>
<h5 id="components-of-smtp">Components of SMTP</h5>
<h6 id="mail-user-agent-mua">Mail User Agent (MUA)</h6>
<p>Computer application that helps the user in sending and receiving
email. Eg - outlook, thunderbird.</p>
<h6 id="mail-submission-agent-msa">Mail submission agent (MSA)</h6>
<p>Used to send email. It receives email from MUA, and interacts with
the MTA for sending it.</p>
<h6 id="mail-transfer-agent-mta">Mail transfer agent (MTA)</h6>
<p>Transfers email from one system to another using SMTP</p>
<h6 id="mail-delivery-agent-mda">Mail delivery agent (MDA)</h6>
<p>Helps deliver email to the local system, put it into appropriate
mailboxes,filter spam etc. It works before the message hits the user’s
inbox.</p>
<h5 id="smtp-commands">SMTP Commands</h5>
<h6 id="helo">HELO</h6>
<p>Identifies the user and the full domain name. This is transmitted
only once per session.</p>
<h6 id="mail">MAIL</h6>
<p>Used to initiate transfer of mail</p>
<h6 id="rcpt">RCPT</h6>
<p>This command comes immediately after MAIL. Used to identify
recipient’s full domain name.</p>
<h6 id="data">DATA</h6>
<p>Data is transferred line by line</p>
<h4 id="message-access-agents---pop-and-imap">Message Access Agents -
POP and IMAP</h4>
<ul>
<li>SMTP is not involved in pulling mail to client. It is only a push
protocol and pushes mail from client to server.</li>
<li>Message Access Agents such as POP (Post Office Protocol) and IMAP
(Internet Mail Access Protocol) are used to pull messages from the
server.</li>
</ul>
<h5 id="pop3">POP3</h5>
<ul>
<li>Simple and limited.</li>
<li>Client opens connection to server on port 110. It sends its username
and password.</li>
<li>It can access mail messages in delete mode or keep mode. In delete
mode, once a message is downloaded from the server, the server will
delete it. The user can keep a local copy. In keep mode, the server side
copy will be kept intact.</li>
</ul>
<h5 id="imap4">IMAP4</h5>
<ul>
<li>More powerful and complex.</li>
<li>User can check email header before downloading the entire
message.</li>
<li>User can search email</li>
<li>Partially downloadable email</li>
<li>Different mailboxes, folders, hierarchy of folders can be
created.</li>
</ul>
<h4 id="mime">MIME</h4>
<p>MIME (Multipurpose Internet Mail Extension) is used to extend the
ability of email.</p>
<ul>
<li>Email generally only supports 7-bit ASCII messages.</li>
<li>MIME allows non-ASCII data, including multimedia, to be sent using
email.</li>
<li>MIME transforms non-ASCII data to NVT ASCII and delivers them to
client MTA. On the receiving side the message is transformed back.</li>
</ul>
<h4 id="extended-smtp-esmtp-vs-smtp">Extended SMTP (ESMTP) vs SMTP</h4>
<table>
<colgroup>
<col style="width: 47%" />
<col style="width: 52%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">ESMTP</th>
<th style="text-align: center;">SMTP</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">Authentication of sender is done</td>
<td style="text-align: center;">No authentication is present.</td>
</tr>
<tr class="even">
<td style="text-align: center;">Multimedia can be attached directly</td>
<td style="text-align: center;">Multimedia can only be attached using
MIME</td>
</tr>
<tr class="odd">
<td style="text-align: center;">Size of email can be reduced</td>
<td style="text-align: center;">Email size cannot be reduced</td>
</tr>
<tr class="even">
<td style="text-align: center;">SSL encryption is done</td>
<td style="text-align: center;">No encryption</td>
</tr>
<tr class="odd">
<td style="text-align: center;">Transmission opened using EHLO
command</td>
<td style="text-align: center;">Transmission opened using HELO
command.</td>
</tr>
</tbody>
</table>
<h3 id="dns">DNS</h3>
<p>DNS stands for domain name system. It is used to convert domain
names, such as google.com, to IP addresses, such as 8.8.8.8. Special DNS
servers are used for this. Many of them exist due to the large number of
websites on the internet that need DNS services.</p>
<h4 id="dns-server-hierarchy">DNS Server Hierarchy</h4>
<h5 id="root-dns-server">Root DNS Server</h5>
<p>This is the highest level in the hierarchy. Many of these exist, and
are operated by very few organizations (around 13). When a root DNS
server is asked to provide the IP of a website, it doesn’t provide the
IP directly. Instead, it provides the IP of the correct TLD DNS server
that will contain the needed website’s IP.</p>
<h5 id="top-level-domain-tld-dns-server">Top-Level Domain (TLD) DNS
Server</h5>
<p>TLDs are used for a particular domain ending - for e.g, .com, .edu,
.in, etc. Each will have a different TLD server. The TLD will point the
query towards the correct authoritative DNS server that contains the
website’s IP.</p>
<h5 id="authoritative-dns-server">Authoritative DNS Server</h5>
<p>Authoritative DNS servers contain a broad list of domain names and
their IP addresses. The authoritative DNS server will return back a
website’s IP address to us.</p>
<h4 id="dns-name-hierarchy">DNS Name Hierarchy</h4>
<p>Suppose we take the domain - www.example.com</p>
<p>A fully qualified domain name (FQDN) always has a . at the end, even
if we don’t write it. So our domain becomes www.example.com.</p>
<p>This can be divided into 4 parts, from right to left.</p>
<ol type="1">
<li><strong>The root level domain</strong> - Represented by the dot at
the end, this is the highest hierarchy level. It is used to denote the
root level DNS server.</li>
<li><strong>TLD</strong> - The TLD in our case is <em>com</em></li>
<li><strong>Second-level domain</strong>- This is the website’s name,
for e.g a business name. In our case it is <em>example</em></li>
<li><strong>Sub-domain</strong> - Here, <em>www</em> is a subdomain. We
can also create more subdomains such as shop.example.com,
cloud.example.com, images.example.com, etc.</li>
</ol>
<h2 id="session-layer">Session Layer</h2>
<h3 id="functions-of-session-layer">Functions of Session Layer</h3>
<ul>
<li>Dialog Control - allow systems to enter into full/half duplex
dialog</li>
<li>Managing tokens</li>
<li>Synchronization</li>
</ul>
<h3 id="design-issues">Design Issues</h3>
<ul>
<li>Establishing sessions between 2 machines - opening, closing and
maintaining a semi-permanent dialogue.</li>
<li>Enhanced services (checkpoints and tokens)</li>
</ul>
<h3 id="rpc-remote-procedure-call">RPC (Remote Procedure Call)</h3>
<p>RPC is a protocol that works in session layer of OSI model, and
application layer of TCP/IP model.</p>
<ul>
<li>RPC is when a client calls a service on a server (or any other
network computer), as if it is calling a function on its own local
system.</li>
<li>Can work on TCP/UDP both, but prefers UDP.</li>
<li>Uses authentication to verify client’s identity.</li>
</ul>
<p>Client -&gt; Client Side API —– RPC ——&gt; Server -&gt; Local
function call -&gt; Return value to client.</p>
<ul>
<li>Client doesn’t see the OSI layers or the network calls. To the
client, it is simply calling a function.</li>
<li><strong>Stubs</strong> are used to convert data to different
formats, as client and server may use different formats for data.</li>
<li>The client stub takes the parameters for the RPC call and puts them
into the message. This is called <strong>parameter marshalling</strong>.
It also puts the name or number of the procedure to be called.</li>
<li>The receiver stubs receives the message, unpacks it and gives it to
the receiver application. The receiver application calls the requested
procedure with the given parameters. The result is packet into a message
by the receiver stub, and send to the client.</li>
<li>The client stub receives the response, unpacks it, and gives it back
to the client application.</li>
</ul>
<h4 id="issues-in-rpc">Issues in RPC</h4>
<ul>
<li><p><strong>Binding</strong> - How does the client know who to call,
what the procedure name is, etc.?</p>
<p>This has 2 solutions:</p>
<ul>
<li><strong>Dynamic Binding</strong> - Find the server when RPC is
called (at runtime)</li>
<li><strong>Naming and Locating</strong> - Server offering a service
exports an interface for it, and registers the interface with the
system. Client must import an interface before communication.</li>
</ul></li>
<li><p>Different formats of data - solved by stubs.</p></li>
<li><p>How to pass parameters - solved by parameter
marshalling.</p></li>
</ul>
<h3 id="types-of-rpc">Types of RPC</h3>
<h4 id="synchronous-rpc">Synchronous RPC</h4>
<p>A calls RPC on B - calling process on A is suspended. Information is
passed as parameters.</p>
<h4 id="asynchronous-rpc">Asynchronous RPC</h4>
<p>Client continues executing other commands after RPC request and
receiving acknowledgment. When it receives the response, it can use
it.</p>
<h4 id="one-way-rpc">One-Way RPC</h4>
<p>Client doesn’t wait for an acknowledgment. This is unreliable since
the receiver may never have received the RPC request.</p>
<h4 id="deferred-synchronous-rpc">Deferred Synchronous RPC</h4>
<p>Client periodically asks(polls) the server if the RPC results are
available yet.</p>
<h3 id="failure-semantics-in-rpc">Failure Semantics in RPC</h3>
<ul>
<li><strong>Client unable to locate server</strong> - Return error to
client application.</li>
<li><strong>Lost request message</strong> - Timeout messages, repeat the
message if we don’t receive a reply after some time.</li>
<li><strong>Lost reply</strong> - Same as above.</li>
<li><strong>Server failure</strong> - Hard to detect if server failed or
if message was lost. We also don’t know if server failed after
completing the procedure (but before sending its reply), or if the
procedure was never executed (server failed before calling it.)</li>
<li><strong>Client failure</strong> - Client fails before it can receive
the reply.</li>
</ul>
<h2 id="presentation-layer---security">Presentation Layer -
Security</h2>
<p>One of the major functions of the presentation layer is security and
cryptography.</p>
<h3 id="types-of-cryptosystems">Types of Cryptosystems</h3>
<h4 id="symmetric">Symmetric</h4>
<p>AKA conventional cryptography/shared-key systems/secret-key
systems.</p>
<p>Sender and receiver share the same key, which is used both for
encryption and decryption.</p>
<p>The shared key must be kept private. Anyone in possession of the key
can read encrypted messages.</p>
<p>The notation <span class="math inline">\(K_{a,b}\)</span> is used to
denote a secret-key shared by <span class="math inline">\(A\)</span> and
<span class="math inline">\(B\)</span>.</p>
<h4 id="asymmetric">Asymmetric</h4>
<p>AKA Public-key cryptography.</p>
<p>The keys for encryption and decryption are different, but form a
unique pair. The key for decryption can only decrypt the data encrypted
with its pair key.</p>
<p>Key for encryption - <span class="math inline">\(K_E\)</span>.</p>
<p>Key for decryption - <span class="math inline">\(K_D\)</span>.</p>
<p>One of the keys is made public, and the other one kept private.</p>
<p>The notation <span class="math inline">\(K_A^+\)</span> is used to
denote a public key belonging to <span class="math inline">\(A\)</span>,
and <span class="math inline">\(K_A^-\)</span> denotes a private key
belonging to <span class="math inline">\(A\)</span>.</p>
<p>If Bob wants to send a message to Alice, he should encrypt it using
Alice’s public key. Since Alice is the only person who possessed the
corresponding private key, only she can decrypt the message.</p>
<h3 id="types-of-ciphers">Types of Ciphers</h3>
<p>Ciphers are algorithms used to change <em>plaintext</em> to
<em>ciphertext</em>. Plaintext is our original information. Ciphertext
is it’s encrypted form. A cipher does character-to-character, or
bit-to-bit transformations. A code, on the other hand, transforms entire
words.</p>
<h4 id="substitution-ciphers">Substitution Ciphers</h4>
<p>Each letter is replaced, or substituted, by another letter. It can
also be done for groups of letters, for e.g, two at a time.</p>
<p>A simple example is the Caesar cipher, in which the letters of the
alphabet are shifted a fixed number of positions. For e.g, if we shift
by 2,</p>
<p>A becomes C, B becomes D, C becomes E, etc.</p>
<p>Modern substitution ciphers are much more complex, and tough to
break.</p>
<h4 id="transposition-ciphers">Transposition Ciphers</h4>
<p>In substitution ciphers, we changed the letters/bits, but kept their
order the same. In transposition ciphers, we will keep the letters the
same, but change their order.</p>
<p>One simple transposition cipher is the columnar transposition, shown
here.</p>
<figure>
<img src="../images/cn/transposition_cipher"
alt="image-20230506141817783" />
<figcaption aria-hidden="true">image-20230506141817783</figcaption>
</figure>
<p>Here, MEGABUCK is the secret key that must not be shared with anyone
except the receiver. We write the plaintext rowwise, with the number of
columns being the length of the key.</p>
<p>We write the ciphertext columnwise. We start with the column whose
key is lowest. Here, lower is determined by position in alphabet. Thus,
we write out column A -&gt; B-&gt;C-&gt;E-&gt;G-&gt;K-&gt;M.</p>
<h4 id="one-time-pad">One-Time Pad</h4>
<p>This is an unbreakable cipher, but it has its own disadvantages.</p>
<ul>
<li><p>Choose a random bit-string as the key.</p></li>
<li><p>Convert the plaintext into bits, for e.g, using ASCII.</p></li>
<li><p>XOR the plaintext with the key. This produces the ciphertext,
which is sent to the receiver.</p></li>
<li><p>To decrypt, the ciphertext is again XORed with the key, and
converted back to character form.</p></li>
<li><p>This is unbreakable, because if a hacker tries to try all
possible keys, he will receive valid (but wrong) answers.</p>
<p>For e.g, if the original message is “Hello World”, using the key
<span class="math inline">\(key_1\)</span>. Suppose the hacker tries to
XOR the ciphertext using <span class="math inline">\(key_2\)</span>, and
he receives the message “Good morning”. He will not know whether “Good
Morning” was the actual message.</p></li>
<li><p>Major issue with one-time pads is that both sender and receiver
need to maintain a copy of the key, that can never be lost or changed.
One key can also not be used a large amount of times, as then hackers
will get a large amount of data to try to guess the key from.</p></li>
</ul>
<h3 id="rsa">RSA</h3>
<p>An asymmetric encryption algorithm named after its inventors -
Rivest, Shamir and Adleman.</p>
<p>Based on the fact that prime factorization of very large numbers is a
difficult and time-consuming process.</p>
<h4 id="steps">Steps</h4>
<ol type="1">
<li><p>Take 2 very large prime numbers - <span
class="math inline">\(p\)</span> and <span
class="math inline">\(q\)</span>.</p></li>
<li><p>Calculate <span class="math display">\[ n = p * q \]</span> <span
class="math display">\[ z = (p-1)*(q-1) \]</span></p></li>
<li><p>Choose <span class="math inline">\(d\)</span> such that <span
class="math inline">\(d\)</span> is relatively prime to <span
class="math inline">\(z\)</span>.</p></li>
<li><p>Compute <span class="math inline">\(e\)</span> such that</p></li>
</ol>
<p><span class="math display">\[ (e*d)\%z =1 \]</span></p>
<p>Now, the number <span class="math inline">\(d\)</span> can be used
for decryption, and <span class="math inline">\(e\)</span> for
encryption.</p>
<p>One of these is kept private, and the other is made public.</p>
<h4 id="usage">Usage</h4>
<p>Let the message to be sent be <span class="math inline">\(m\)</span>.
Here, <span class="math inline">\(m\)</span> is interpreted simply as a
binary number.</p>
<ol type="1">
<li>Divide <span class="math inline">\(m\)</span> into fixed length
blocks, <span class="math inline">\(m_i\)</span>, such that:</li>
</ol>
<p><span class="math display">\[ 0 \le m_i \le n \]</span></p>
<p>Each <span class="math inline">\(m_i\)</span> is also interpreted as
a binary number.</p>
<ol start="2" type="1">
<li><p>The sender calculates <span class="math display">\[ c_i = (m_i^e)
\% n \]</span> All such <span class="math inline">\(c_i\)</span> are
calculated and concatenated into a single variable <span
class="math inline">\(c\)</span>.</p></li>
<li><p><span class="math inline">\(c\)</span> is sent to the
receiver.</p></li>
<li><p>The receiver calculates <span class="math display">\[ y_i =
(c_i^d) \% n \]</span></p></li>
</ol>
<p>Based on the properties of modulus, and the way we have chosen <span
class="math inline">\(e\)</span> and <span
class="math inline">\(d\)</span>, we can easily see that <span
class="math inline">\(y_i=m_i \forall i\)</span>.</p>
<p>This way, the receiver is able to reconstruct the message.</p>
<h4 id="properties-of-rsa">Properties of RSA</h4>
<ul>
<li>RSA is secure because no method exist to (efficiently) find prime
factors of large numbers.</li>
<li>RSA itself is also computationally expensive, around 100-1000x
slower than DES.</li>
<li>It’s generally used to securely share session keys, and then those
session keys are used in a (faster) encryption algorithm, such as AES or
DES.</li>
</ul>
<h3 id="securely-sending-messages-secure-channels">Securely sending
messages (Secure Channels)</h3>
<p>Securely sending messages has the following problems to solve.</p>
<ul>
<li><p><strong>Confidentiality</strong></p>
<p>No one else other than the intended recipient should be able to read
the message.</p></li>
<li><p><strong>Integrity</strong></p>
<p>The recipient should have a way to be sure that the contents of the
message weren’t tampered.</p></li>
<li><p><strong>Authentication</strong></p>
<p>Both parties should have a way to be confident that they are sending
messages to the right person.</p></li>
</ul>
<h4 id="digital-signatures">Digital Signatures</h4>
<p>Confidentiality and Integrity needs to be maintained in secure
channels.</p>
<ul>
<li>Alice needs to be sure that Bob cannot alter a message and claim
that Alice sent it.</li>
<li>Bob needs to be able to prove that a message indeed came from Alice,
and that she cannot deny having sent it.</li>
</ul>
<p><strong>Digital Signatures</strong> are used for this. The document
is signed using the sender’s public key, which uniquely ties the sender
to the message.</p>
<ul>
<li>Alice sends a message <span class="math inline">\(m\)</span> to Bob.
She encrypts it with <em>her</em> private key to create a
<strong><em>signature</em></strong>. The signature and the original
message are sent to Bob.
<ul>
<li>If she wants to keep the message content a secret, she can encrypt
the entire thing using Bob’s public key.</li>
<li>The message will then be <span
class="math inline">\(K_B^+(m,K_A^-(m))\)</span>, where <span
class="math inline">\(K_A^-(m)\)</span> is the signature.</li>
</ul></li>
<li>Message arrives at Bob.
<ul>
<li>If it’s secret, he first decrypts it using his private key.</li>
</ul></li>
<li>He decrypts the signature using Alice’s public key, and matches it
with <span class="math inline">\(m\)</span>. If the decrypted signature
and <span class="math inline">\(m\)</span> match, then he can be sure
the message was sent from Alice and is untampered with.</li>
<li>Alice cannot claim she never sent the message, or sent a different
message, because Bob has the signed version of <span
class="math inline">\(m\)</span>, and only Alice could have signed it,
since only she possesses her private key.</li>
<li>Bob cannot claim Alice sent a modified message, because he would
have to prove that Alice signed the modified message as well.</li>
</ul>
<figure>
<img src="../images/obs/digital_signatures.png"
alt="Digitally signing messsages" />
<figcaption aria-hidden="true">Digitally signing messsages</figcaption>
</figure>
<h5 id="issues-with-this-scheme">Issues with this scheme</h5>
<ul>
<li>This remains valid only as long as Alice’s private key remains
private. If the key is stolen or leaked, Alice will have to generate a
new key, and all messages signed using the previous key will then become
worthless.</li>
<li>If the message is long, encrypting the entire message may be
computationally expensive.</li>
</ul>
<p>A solution for the second problem is a <strong>message
digest</strong>.</p>
<h5 id="message-digest">Message Digest</h5>
<p>It’s a fixed length string <span class="math inline">\(h\)</span>
that’s computed from a message <span class="math inline">\(m\)</span> of
arbitrary length, using a hash function <span
class="math inline">\(H\)</span>.</p>
<p>If <span class="math inline">\(m\)</span> is changed to <span
class="math inline">\(m&#39;\)</span>, then it’s hash <span
class="math inline">\(H(m&#39;)\)</span> will not be the same as before
(<span class="math inline">\(H(m)\)</span>). Thus, modifications will
easily be detected.</p>
<p>Instead of signing <span class="math inline">\(m\)</span>, Alice
signs <span class="math inline">\(H(m)\)</span>, which becomes the
signature.</p>
<p>The message sent to Bob is now <span
class="math inline">\(K_B^+(m,K_A^-(H(m)))\)</span>, where <span
class="math inline">\(K_A^-(H(m))\)</span> is the signature.</p>
<p>On Bob’s end, Bob will hash the entire message himself, decrypt the
signature, and compare the hashes. If they match, all is good.</p>
<figure>
<img src="../images/obs/digital_signatures_using_digest.png"
alt="Digitally signing messages using digests" />
<figcaption aria-hidden="true">Digitally signing messages using
digests</figcaption>
</figure>
<h4 id="diffie-hellman-key-exchange">Diffie-Hellman Key Exchange</h4>
<p>This is a method for 2 parties to exchange keys without the use of a
third party.</p>
<ol type="1">
<li>Alice and Bob agree on 2 large numbers, <span
class="math inline">\(n\)</span> and <span
class="math inline">\(g\)</span>. Both numbers can be made public.</li>
<li>Alice chooses a large number <span class="math inline">\(x\)</span>
and keeps it private, and Bob chooses a large number <span
class="math inline">\(y\)</span>, and also keeps it private. Alice does
not know <span class="math inline">\(y\)</span> and Bob doesn’t know
<span class="math inline">\(x\)</span>.</li>
<li>Alice sends <span class="math inline">\(g^x\;mod\;n\)</span> to
Bob.</li>
<li>Bob sends <span class="math inline">\(g^y\;mod\;n\)</span> to
Alice.</li>
<li>Alice computes <span class="math inline">\(K_{A,B}\)</span> as:
<span class="math display">\[ K_{A,B} = (g^y\;mod\;n)^x = g^{xy}\; mod
\; n\]</span></li>
<li>Bob computes <span class="math inline">\(K_{A,B}\)</span> as: <span
class="math display">\[ K_{A,B} = (g^x\;mod\;n)^y = g^{xy}\; mod \;
n\]</span></li>
</ol>
<p>This way both Alice and Bob get the same session key, and no one
listening from outside will be able to recreate it. This is based on the
same principle as <a href="#rsa">RSA</a>.</p>
</div></div></body>
</html>
