<!DOCTYPE html>
<html ontouchmove="" xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Satvik Gupta" />
  <title>Computer Networks - Important Topics Only</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
  </style>
  <link rel="stylesheet" href="styles.css" />
  
  <script
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js"
  type="text/javascript"></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-WX57KF6HY8"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-WX57KF6HY8');
</script></head>
<body>
    
    <div id="navbar" onclick="">

    <div id="navbar_text">
        .satvik
    </div>
    <div id="navbar_links">
        <div class="navbar_link" id="home_link">
            <a href="/#home" target="_self">Home</a>
        </div>
        <div class="navbar_link" id="workexp_link">
            <a href="/#workexp" target="_self">
                Work Experience
            </a>
        </div>
        <div class=" navbar_link" id="projects_link">
            <a href="/#projects" target="_self">Projects</a>
        </div>
        <div class=" navbar_link" id="notes_link">
        <a href="/notes" target="_self">Notes</a>
    </div>
        <div class=" navbar_link" id="contacts_link">
            <a href="/#contact" target="_self">Contact</a>
        </div>
      
        
    </div>
</div>

<header id="title-block-header">
<h1 class="title">Computer Networks - Important Topics Only</h1>
<p class="author">Satvik Gupta</p>
</header><div id="container">
<nav id="TOC" role="doc-toc"><div class="pdf_link_container"><a class="pdf_link" href="/notes/pdfs/CN_Short.pdf">Download as PDF</a></div>
<ul>
<li><a href="#introduction" id="toc-introduction">Introduction</a>
<ul>
<li><a href="#data-communication" id="toc-data-communication">Data
communication</a>
<ul>
<li><a href="#components-of-effective-data-communication"
id="toc-components-of-effective-data-communication">Components of
Effective Data Communication</a></li>
<li><a href="#components-of-data-communication-system"
id="toc-components-of-data-communication-system">Components of Data
communication system</a></li>
<li><a href="#types-of-communication"
id="toc-types-of-communication">Types of Communication</a></li>
</ul></li>
</ul></li>
<li><a href="#physical-topology" id="toc-physical-topology">Physical
Topology</a>
<ul>
<li><a href="#bus-topology" id="toc-bus-topology">Bus Topology</a></li>
<li><a href="#ring-topology" id="toc-ring-topology">Ring
Topology</a></li>
<li><a href="#star-topology" id="toc-star-topology">Star
Topology</a></li>
<li><a href="#mesh-topology" id="toc-mesh-topology">Mesh
Topology</a></li>
<li><a href="#tree-topology" id="toc-tree-topology">Tree
Topology</a></li>
</ul></li>
<li><a href="#osi-model---open-systems-interconnection"
id="toc-osi-model---open-systems-interconnection">OSI Model - Open
Systems Interconnection</a>
<ul>
<li><a href="#data-in-layers" id="toc-data-in-layers">Data in
layers:</a></li>
</ul></li>
<li><a href="#physical-layer" id="toc-physical-layer">Physical Layer</a>
<ul>
<li><a href="#switched-networks" id="toc-switched-networks">Switched
Networks</a></li>
<li><a href="#types-of-communication-on-the-basis-of-connection"
id="toc-types-of-communication-on-the-basis-of-connection">Types of
Communication on the basis of Connection</a>
<ul>
<li><a href="#connection-oriented"
id="toc-connection-oriented">Connection-Oriented</a></li>
<li><a href="#connectionless"
id="toc-connectionless">Connectionless</a></li>
</ul></li>
</ul></li>
<li><a href="#data-link-layer" id="toc-data-link-layer">Data Link
Layer</a>
<ul>
<li><a href="#delay" id="toc-delay">Delay</a>
<ul>
<li><a href="#transmission-delay"
id="toc-transmission-delay">Transmission Delay</a></li>
<li><a href="#propagation-delay" id="toc-propagation-delay">Propagation
Delay</a></li>
</ul></li>
<li><a href="#framing-techniques" id="toc-framing-techniques">Framing
Techniques</a>
<ul>
<li><a href="#flag-character-stuffingbyte-stuffing"
id="toc-flag-character-stuffingbyte-stuffing">Flag (Character
Stuffing/Byte Stuffing)</a></li>
<li><a href="#bit-stuffing" id="toc-bit-stuffing">Bit Stuffing</a></li>
</ul></li>
<li><a href="#error-detection-and-control"
id="toc-error-detection-and-control">Error Detection and Control</a>
<ul>
<li><a href="#crc-cyclic-redundancy-check"
id="toc-crc-cyclic-redundancy-check">CRC (Cyclic Redundancy
Check)</a></li>
</ul></li>
<li><a href="#flow-control" id="toc-flow-control">Flow Control</a>
<ul>
<li><a href="#stop-wait-arq-automatic-repeat-request"
id="toc-stop-wait-arq-automatic-repeat-request">Stop &amp; Wait ARQ
(Automatic Repeat ReQuest)</a></li>
<li><a href="#formulas" id="toc-formulas">Formulas</a></li>
<li><a href="#go-back-n" id="toc-go-back-n">Go Back N</a></li>
<li><a href="#selective-repeat-sr"
id="toc-selective-repeat-sr">Selective Repeat (SR)</a></li>
<li><a href="#data-encoding-techniques"
id="toc-data-encoding-techniques">Data Encoding Techniques</a></li>
</ul></li>
</ul></li>
<li><a href="#media-access-sublayer"
id="toc-media-access-sublayer">Media Access Sublayer</a>
<ul>
<li><a href="#media-access-control-and-multiple-access-protocols"
id="toc-media-access-control-and-multiple-access-protocols">Media Access
Control and Multiple Access Protocols</a></li>
<li><a href="#random-access-contention-methods"
id="toc-random-access-contention-methods">Random Access/ Contention
Methods</a>
<ul>
<li><a href="#pure-aloha" id="toc-pure-aloha">Pure Aloha</a></li>
<li><a href="#slotted-aloha" id="toc-slotted-aloha">Slotted
Aloha</a></li>
<li><a href="#csma-carrier-sense-multiple-access"
id="toc-csma-carrier-sense-multiple-access">CSMA (Carrier Sense Multiple
Access)</a></li>
<li><a href="#persistence-methods-for-csma"
id="toc-persistence-methods-for-csma">Persistence Methods for
CSMA</a></li>
<li><a href="#csma-with-collision-detection-csmacd"
id="toc-csma-with-collision-detection-csmacd">CSMA with Collision
Detection (CSMA/CD)</a></li>
</ul></li>
</ul></li>
<li><a href="#network-layer" id="toc-network-layer">Network Layer</a>
<ul>
<li><a href="#classful-addressing" id="toc-classful-addressing">Classful
Addressing</a>
<ul>
<li><a href="#class-a" id="toc-class-a">Class A</a></li>
<li><a href="#class-b" id="toc-class-b">Class B</a></li>
<li><a href="#class-c" id="toc-class-c">Class C</a></li>
<li><a href="#class-d" id="toc-class-d">Class D</a></li>
<li><a href="#class-e" id="toc-class-e">Class E</a></li>
</ul></li>
<li><a href="#classless-addressing"
id="toc-classless-addressing">Classless Addressing</a>
<ul>
<li><a href="#rules-for-classless-addressing"
id="toc-rules-for-classless-addressing">Rules for Classless
Addressing</a></li>
</ul></li>
<li><a href="#subnetting" id="toc-subnetting">Subnetting</a>
<ul>
<li><a href="#subnetting-in-classful-addressing"
id="toc-subnetting-in-classful-addressing">Subnetting in Classful
Addressing</a></li>
<li><a href="#subnetting-in-classless-addressing"
id="toc-subnetting-in-classless-addressing">Subnetting in Classless
Addressing</a></li>
<li><a href="#variable-length-subnet-masking-vlsm"
id="toc-variable-length-subnet-masking-vlsm">Variable Length Subnet
Masking (VLSM)</a></li>
</ul></li>
<li><a href="#header-formats-for-ip-protocols"
id="toc-header-formats-for-ip-protocols">Header Formats for IP
Protocols</a>
<ul>
<li><a href="#ipv4-header-format" id="toc-ipv4-header-format">IPv4
Header Format</a></li>
<li><a href="#ipv6-header" id="toc-ipv6-header">IPv6 Header</a></li>
</ul></li>
<li><a href="#routing-protocols" id="toc-routing-protocols">Routing
Protocols</a>
<ul>
<li><a href="#distance-vector-routing-dvr"
id="toc-distance-vector-routing-dvr">Distance Vector Routing
(DVR)</a></li>
<li><a href="#link-state-routing" id="toc-link-state-routing">Link State
Routing</a></li>
</ul></li>
</ul></li>
<li><a href="#transport-layer" id="toc-transport-layer">Transport
Layer</a>
<ul>
<li><a href="#responsibilities"
id="toc-responsibilities">Responsibilities</a></li>
<li><a href="#socket-address-and-port-numbers"
id="toc-socket-address-and-port-numbers">Socket Address and Port
Numbers</a>
<ul>
<li><a href="#port-number-types" id="toc-port-number-types">Port Number
Types</a></li>
</ul></li>
<li><a href="#tcp-transmission-control-protocol"
id="toc-tcp-transmission-control-protocol">TCP (Transmission Control
Protocol)</a>
<ul>
<li><a href="#characteristics"
id="toc-characteristics">Characteristics</a></li>
<li><a href="#tcp-header" id="toc-tcp-header">TCP Header</a></li>
<li><a href="#tcp-connection-establishment"
id="toc-tcp-connection-establishment">TCP Connection
Establishment</a></li>
<li><a href="#tcp-connection-termination"
id="toc-tcp-connection-termination">TCP Connection Termination</a></li>
<li><a href="#tcp-congestion-control"
id="toc-tcp-congestion-control">TCP Congestion Control</a></li>
<li><a href="#tcp-timers" id="toc-tcp-timers">TCP Timers</a></li>
</ul></li>
<li><a href="#udp" id="toc-udp">UDP</a>
<ul>
<li><a href="#characteristics-1"
id="toc-characteristics-1">Characteristics</a></li>
<li><a href="#header" id="toc-header">Header</a></li>
<li><a href="#udp-applications" id="toc-udp-applications">UDP
Applications</a></li>
</ul></li>
<li><a href="#tcp-vs-udp" id="toc-tcp-vs-udp">TCP vs UDP</a></li>
</ul></li>
<li><a href="#application-layer" id="toc-application-layer">Application
Layer</a>
<ul>
<li><a href="#paradigms" id="toc-paradigms">Paradigms</a></li>
<li><a href="#file-transferring" id="toc-file-transferring">File
Transferring</a>
<ul>
<li><a href="#ftp-file-transfer-protocol"
id="toc-ftp-file-transfer-protocol">FTP (File Transfer
Protocol)</a></li>
</ul></li>
<li><a href="#email" id="toc-email">Email</a>
<ul>
<li><a href="#smtp" id="toc-smtp">SMTP</a></li>
<li><a href="#message-access-agents---pop-and-imap"
id="toc-message-access-agents---pop-and-imap">Message Access Agents -
POP and IMAP</a></li>
</ul></li>
<li><a href="#dns" id="toc-dns">DNS</a>
<ul>
<li><a href="#dns-server-hierarchy" id="toc-dns-server-hierarchy">DNS
Server Hierarchy</a></li>
<li><a href="#dns-name-hierarchy" id="toc-dns-name-hierarchy">DNS Name
Hierarchy</a></li>
</ul></li>
</ul></li>
<li><a href="#session-layer" id="toc-session-layer">Session Layer</a>
<ul>
<li><a href="#functions-of-session-layer"
id="toc-functions-of-session-layer">Functions of Session Layer</a></li>
<li><a href="#design-issues" id="toc-design-issues">Design
Issues</a></li>
<li><a href="#rpc-remote-procedure-call"
id="toc-rpc-remote-procedure-call">RPC (Remote Procedure Call)</a>
<ul>
<li><a href="#issues-in-rpc" id="toc-issues-in-rpc">Issues in
RPC</a></li>
</ul></li>
</ul></li>
<li><a href="#presentation-layer---security"
id="toc-presentation-layer---security">Presentation Layer - Security</a>
<ul>
<li><a href="#types-of-cryptosystems"
id="toc-types-of-cryptosystems">Types of Cryptosystems</a>
<ul>
<li><a href="#symmetric" id="toc-symmetric">Symmetric</a></li>
<li><a href="#asymmetric" id="toc-asymmetric">Asymmetric</a></li>
</ul></li>
<li><a href="#types-of-ciphers" id="toc-types-of-ciphers">Types of
Ciphers</a>
<ul>
<li><a href="#substitution-ciphers"
id="toc-substitution-ciphers">Substitution Ciphers</a></li>
<li><a href="#transposition-ciphers"
id="toc-transposition-ciphers">Transposition Ciphers</a></li>
</ul></li>
<li><a href="#rsa" id="toc-rsa">RSA</a>
<ul>
<li><a href="#steps" id="toc-steps">Steps</a></li>
<li><a href="#usage" id="toc-usage">Usage</a></li>
<li><a href="#properties-of-rsa" id="toc-properties-of-rsa">Properties
of RSA</a></li>
</ul></li>
<li><a href="#securely-sending-messages-secure-channels"
id="toc-securely-sending-messages-secure-channels">Securely sending
messages (Secure Channels)</a>
<ul>
<li><a href="#digital-signatures" id="toc-digital-signatures">Digital
Signatures</a></li>
</ul></li>
</ul></li>
</ul>
</nav><div id="data">
<h2 id="introduction">Introduction</h2>
<h3 id="data-communication">Data communication</h3>
<p>It is the exchange of data between two or more devices via some
transmission medium</p>
<h4 id="components-of-effective-data-communication">Components of
Effective Data Communication</h4>
<ul>
<li>Delivery: The data should be delivered to the destination it was
intended to.</li>
<li>Accuracy</li>
<li>Timeliness</li>
<li>Jitter free</li>
</ul>
<h4 id="components-of-data-communication-system">Components of Data
communication system</h4>
<ul>
<li>Sender</li>
<li>Receiver</li>
<li>Message</li>
<li>Protocols</li>
<li>Communication/Transmission medium</li>
</ul>
<h4 id="types-of-communication">Types of Communication</h4>
<ul>
<li>Simplex: Unidirectional communication.</li>
<li>Half Duplex: Bidirectional communication but only one direction at a
time.</li>
<li>Full Duplex: Two simplex connections in opposite directions.</li>
</ul>
<hr />
<h2 id="physical-topology">Physical Topology</h2>
<p>It tells how systems are physically connected through links. It is a
geometric representation of the network.</p>
<h3 id="bus-topology">Bus Topology</h3>
<p>Only one connection.</p>
<figure>
<img src="../images/cn/bus_topology.png" width="200"
alt="Bus Topology" />
<figcaption aria-hidden="true">Bus Topology</figcaption>
</figure>
<p><strong><em>Advantages</em></strong></p>
<ul>
<li>Easy to install</li>
<li>Cheap</li>
<li>Easy to expand</li>
</ul>
<p><strong><em>Disadvantages</em></strong></p>
<ul>
<li>Only one device can transmit at a time, which makes it low
speed.</li>
<li>Single point of failure - faulty cable can bring down the whole
system.</li>
</ul>
<h3 id="ring-topology">Ring Topology</h3>
<figure>
<img src="../images/cn/ring_topology.png" width="200"
alt="Ring Topology" />
<figcaption aria-hidden="true">Ring Topology</figcaption>
</figure>
<p>Tokens are used to transfer data. Only one system can hold the token
at a time. Token passing is done.</p>
<p><strong>Advantages</strong></p>
<ul>
<li>Cheap</li>
</ul>
<p><strong><em>Disadvantages</em></strong></p>
<ul>
<li>Not easy to install.</li>
<li>Not easy to expand.</li>
<li>If one system/one link goes down the entire ring will go down.</li>
</ul>
<h3 id="star-topology">Star Topology</h3>
<p>Uses a central hub.</p>
<figure>
<img src="../images/cn/star_topology.png" width="200"
alt="Star Topology" />
<figcaption aria-hidden="true">Star Topology</figcaption>
</figure>
<p><strong><em>Advantages and disadvantages same as of any centralized
system</em></strong> Hub can also be expensive.</p>
<h3 id="mesh-topology">Mesh Topology</h3>
<figure>
<img src="../images/cn/mesh_topology.png" width="200" alt="Mesh" />
<figcaption aria-hidden="true">Mesh</figcaption>
</figure>
<p><strong><em>Advantages</em></strong></p>
<ul>
<li>Less traffic</li>
<li>No single point of failure</li>
<li>Messages can be sent directly without any routing</li>
</ul>
<p><strong><em>Disadvantages</em></strong></p>
<ul>
<li>Cabling cost will be higher</li>
<li>Maintenance cost will be higher.</li>
</ul>
<h3 id="tree-topology">Tree Topology</h3>
<p>Tree structure.</p>
<figure>
<img src="../images/cn/tree_topology.png" width="200"
alt="Tree Topology" />
<figcaption aria-hidden="true">Tree Topology</figcaption>
</figure>
<h2 id="osi-model---open-systems-interconnection">OSI Model - Open
Systems Interconnection</h2>
<p>Given by ISO.</p>
<figure>
<img src="../images/cn/osi.jpg" width="400" alt="OSI" />
<figcaption aria-hidden="true">OSI</figcaption>
</figure>
<h3 id="data-in-layers">Data in layers:</h3>
<table>
<colgroup>
<col style="width: 3%" />
<col style="width: 14%" />
<col style="width: 5%" />
<col style="width: 59%" />
<col style="width: 17%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">S.No</th>
<th style="text-align: center;">Layer</th>
<th style="text-align: center;">Data</th>
<th style="text-align: left;">Responsibility</th>
<th style="text-align: left;">Protocols</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">1</td>
<td style="text-align: center;">Application Layer</td>
<td style="text-align: center;">Data</td>
<td style="text-align: left;">To allow access to network resources</td>
<td style="text-align: left;">Telnet, SMTP,DNS, HTTP</td>
</tr>
<tr class="even">
<td style="text-align: center;">2</td>
<td style="text-align: center;">Presentation Layer</td>
<td style="text-align: center;">Data</td>
<td style="text-align: left;">To translate, encrypt and process the
data</td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;">3</td>
<td style="text-align: center;">Session Layer</td>
<td style="text-align: center;">Data</td>
<td style="text-align: left;">To establish, manage and terminate
session</td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: center;">4</td>
<td style="text-align: center;">Transport Layer</td>
<td style="text-align: center;">Segment</td>
<td style="text-align: left;">Process to Process msg delivery, error
recovery</td>
<td style="text-align: left;">TCP, UDP</td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">(Port/Socket Address)</td>
</tr>
<tr class="even">
<td style="text-align: center;">5</td>
<td style="text-align: center;">Network Layer</td>
<td style="text-align: center;">Packet</td>
<td style="text-align: left;">Move packet from source to
destination.</td>
<td style="text-align: left;">IP, ARP, RARP, ICMP</td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">(Logical/IP Address)</td>
</tr>
<tr class="even">
<td style="text-align: center;">6</td>
<td style="text-align: center;">Data Link Layer</td>
<td style="text-align: center;">Frame</td>
<td style="text-align: left;">Hop to hop delivery, organize the
frames</td>
<td style="text-align: left;">IEEE 802 Std., TR,PPP</td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">(Physical/MAC Address)</td>
</tr>
<tr class="even">
<td style="text-align: center;">7</td>
<td style="text-align: center;">Physical Layer</td>
<td style="text-align: center;">Bit</td>
<td style="text-align: left;">Transmit bits over a medium, provide
mechanical and electrical specification</td>
<td style="text-align: left;">Transmission media</td>
</tr>
</tbody>
</table>
<p><strong>ARP</strong> - Address Resolution Protocol - Maps IP to
MAC.</p>
<p><strong>RARP</strong> - Reverse Address Resolution Protocol - Maps
MAC to IP.</p>
<h2 id="physical-layer">Physical Layer</h2>
<p>It is responsible for moving physical bits. It defines:</p>
<ul>
<li>a transmission medium (wireless/wired)</li>
<li>types of encoding to be used</li>
<li>data rate</li>
<li>synchronization of bits</li>
<li>physical topology</li>
</ul>
<h3 id="switched-networks">Switched Networks</h3>
<p>Large networks cannot have all nodes directly connected with each
other. Therefore, to send data from one node to another, it has to be
sent through other nodes.</p>
<p>Suppose there’s a network with many nodes, and node A wants to send
some data to node B. There are two ways of doing so.</p>
<ol type="1">
<li><p><strong>Packet Switching</strong></p>
<p>Data is divided into small sized packets for transmission. This
increased efficiency, reduces chances of lost data,etc.</p>
<ol type="1">
<li><strong>Virtual Circuit</strong> - Source establishes a (virtual)
path that the data will follow. Each packet goes through the same
route.</li>
<li><strong>Datagram Switching</strong> - Source doesn’t decide any
route. It sends each packet to the next nodes. Each node can decide
where to forward the packets. Each packet may end up taking a different
route. Packets may be delivered in a different order.</li>
</ol></li>
<li><p><strong>Circuit Switching</strong></p>
<p>A special path is set up for the transmission, and the intermediate
nodes are already decided before the data transmission takes place.
There is a dedicated path set up for the transmission of that
packet.</p></li>
<li><p><strong>Message Switching</strong> - Entire message is
transferred between nodes. Each node stores the message, then decides
where to forward it. This is also called <em>store and
forward</em>.</p></li>
</ol>
<h3 id="types-of-communication-on-the-basis-of-connection">Types of
Communication on the basis of Connection</h3>
<h4 id="connection-oriented">Connection-Oriented</h4>
<ul>
<li>Similar to telephone.</li>
<li>Establish a connection, communicate, and then release the
connection.</li>
</ul>
<h4 id="connectionless">Connectionless</h4>
<ul>
<li>Like postal system</li>
<li>Each packet has the destination address,</li>
<li>Each packet is routed independently through the system.</li>
</ul>
<h2 id="data-link-layer">Data Link Layer</h2>
<h3 id="delay">Delay</h3>
<h4 id="transmission-delay">Transmission Delay</h4>
<p>The delay taken for the host to put the data onto the transmission
line.</p>
<p><span class="math display">\[ T_t = L/B \]</span></p>
<p>where <span class="math inline">\(L\)</span> is the size of the data,
and <span class="math inline">\(B\)</span> is the bandwidth.</p>
<h4 id="propagation-delay">Propagation Delay</h4>
<p>Time taken by the last bit of the data to reach the destination
(after it has been transmitted from host to transmission media at the
source.)</p>
<p><span class="math display">\[ T_p = distance/velocity \]</span></p>
<h3 id="framing-techniques">Framing Techniques</h3>
<p>One of the major issue in framing is to decide how to specify the
start and end of a frame.</p>
<h4 id="flag-character-stuffingbyte-stuffing">Flag (Character
Stuffing/Byte Stuffing)</h4>
<p>We use a special <strong>flag byte</strong> at the start and end of
each frame. It is fixed so it can be recognized.</p>
<p>An issue with this is that the flag byte may occur “accidentally” in
the data itself. This may cause the DLL to assume the frame has ended
even when it has not.</p>
<p>To solve this, we use a special <strong>ESC</strong> byte, which is
also fixed. Accidental flag bytes have the ESC sequence inserted before
them, to tell the DLL that this FLAG is data and not the end of a
frame.</p>
<p>If ESC occurs within the data “accidentally”, we escape it with
another ESC.</p>
<h5 id="examples">Examples</h5>
<p>A Flag B –&gt; A ESC Flag B</p>
<p>A ESC B –&gt; A ESC ESC B</p>
<p>A ESC Flag B –&gt; A ESC ESC ESC Flag B</p>
<p>A ESC ESC B –&gt; A ESC ESC ESC ESC B</p>
<p><strong>Doesn’t work if the data isn’t 8-bit.</strong></p>
<h4 id="bit-stuffing">Bit Stuffing</h4>
<p>A special bit pattern denotes start and end of frames. Generally,
this is taken to be <code>01111110</code>.</p>
<p>If the sender encounters the starting of this pattern in the data, it
adds a 0 or a 1 before it ends so that the pattern never occurs. The
receiver will do the opposite and remove the <em>stuffed</em> 0s or
1s.</p>
<p>For e.g, for <code>01111110</code>,</p>
<p>If the sender encounters a 0 followed by 5 consecutive 1’s, it adds a
0 before continuing. This ensures that <code>01111110</code> never
occurs in the data.</p>
<p>The receiver will <em>destuff</em> these extra zeroes on its end.</p>
<p><code>01111110</code> –&gt; <code>011111010</code></p>
<p><code>011011111111111111110010</code> –&gt;
<code>011011111011111011111010010</code></p>
<h3 id="error-detection-and-control">Error Detection and Control</h3>
<h4 id="crc-cyclic-redundancy-check">CRC (Cyclic Redundancy Check)</h4>
<p>Data - k-bit Codeword - n-bit Divisor - (n-k+1) bits. Divisor should
be mutually agreed between sender and receiver.</p>
<ul>
<li>Add (n-k) <code>0</code>s to the dataword.</li>
<li>Divide dataword by divisor using <em>modulo-2 division</em>.</li>
<li>Append the remainder found to the original dataword (without the
extra zeroes)</li>
</ul>
<p>At receiver’s side:</p>
<ul>
<li>Perform modulo-2 division of the received code-word and
divisor.</li>
<li>If the remainder is 0, the data is correct. Otherwise it’s
incorrect.</li>
</ul>
<h5 id="modulo-2-division">Modulo-2 Division</h5>
<p>It’s a method of dividing 2 binary numbers.</p>
<p>It follows the rules and logic of normal division, with subtraction
step replaced by bitwise XOR.</p>
<p><img src="../images/cn/crc.jpg" /></p>
<h3 id="flow-control">Flow Control</h3>
<p>To make sure receiver receives all the data.</p>
<h4 id="stop-wait-arq-automatic-repeat-request">Stop &amp; Wait ARQ
(Automatic Repeat ReQuest)</h4>
<ul>
<li>Sender sends a frame and waits for ACK (acknowledgement) for the
frame from receiver.</li>
<li>Receiver receives the frame. If the frame is correct, receiver sends
ACK.</li>
<li>If the frame is corrupt, receiver drops the frame and does
nothing.</li>
<li>Sender waits a certain amount of time for ACK from receiver. After
this, it times out and resends the frame.</li>
<li>ACK message may also get lost, then the sender will assume the
original frame was corrupted or lost. It will retransmit, which means
the receiver may get duplicate data.</li>
<li>To avoid this, frames are numbered.
<ul>
<li>We only need to differentiate between a frame and its immediate
successor. I.e, we need to differentiate between frame x and x+1.
Therefore, 1 bit sequence number is enough. If the first frame is 0, the
second frame is 1, the third is again 0, and so on.</li>
</ul></li>
</ul>
<h4 id="formulas">Formulas</h4>
<p>Efficiency = <span class="math inline">\(\eta\)</span> = Useful Time/
Total Time <span class="math display">\[ =
\frac{1}{1+2(\frac{T_p}{T_t})} \]</span> <span class="math display">\[ =
\frac{1}{1+2a} \]</span></p>
<p>where a = <span class="math inline">\(T_p/T_t\)</span>.</p>
<p>where <span class="math inline">\(T_p\)</span> is propagation time
and <span class="math inline">\(T_t\)</span> is transmissiontime</p>
<p>Throughput = <span class="math inline">\(\eta\)</span> *
Bandwidth</p>
<h4 id="go-back-n">Go Back N</h4>
<ul>
<li>Sliding Window Protocol</li>
<li>Receiver window Size = 1</li>
<li>Sender Window Size = <span class="math inline">\(2^m-1\)</span></li>
<li>Sequence numbers for frames – <span
class="math inline">\([0,1,....2^m-1]\)</span>, 0 and <span
class="math inline">\(2^m-1\)</span> inclusive.</li>
<li>Window Size = WS/W</li>
<li>We send up to W frames at a time, and keep them in memory until the
receiver ACKs them.</li>
<li>Receiver only receives one frame at a time.</li>
<li>Receiver can send a single ACK for many frames. For eg if sender
sent 7,8,9 and receiver received all, it can simply send ACK 10.</li>
<li>If receiver receives wrong frame (e.g receiver was waiting for frame
3 and frame 4 came), or a corrupted frame, it stays silent.</li>
<li>Sender’s timer will timeout. Sender will resend all frames in the
window.</li>
</ul>
<p>For e.g, if WS=3 and sender has sent 1,2,3,4,5,6 and timer for 3
times out (1 and 2 ACKed successfully), sender will send 3,4,5
again.</p>
<p>Efficiency = <span class="math inline">\(\eta =
\frac{WS}{1+2a}\)</span></p>
<p>where <span class="math inline">\(a=T_p/T_t\)</span></p>
<p><strong>For maximum efficiency (100% usage),</strong></p>
<ul>
<li><p>WS = 1+2a</p></li>
<li><p>No. of bits needed for sequence number = <span
class="math inline">\(\lceil log(1+2a) \rceil\)</span></p></li>
</ul>
<h4 id="selective-repeat-sr">Selective Repeat (SR)</h4>
<ul>
<li><p>Only lost/corrupted frames are resent.</p></li>
<li><p>Sender window size = Receiver Window Size</p></li>
<li><p>Window Size = <span class="math inline">\(2^m/2\)</span></p></li>
<li><p>Receiver buffers frames that are within its window range. Others
are dropped. For e.g, if receiver’s window is waiting for frames 3,4,5
and sender sends 6, it will be dropped.</p></li>
<li><p>ACK is only sent after frames are received in order. If receiver
window is 3,4,5 and we receive 4,5 - 4,5 will be stored and buffered,
but no ACK will be sent.</p>
<p>Instead, receiver will send a negative acknowledgement (NACK) for 3 -
NACK 3.</p></li>
<li><p>This tells the sender that receiver hasn’t received 3.</p></li>
<li><p>Sender will resend 3 (only 3).</p></li>
<li><p>When 3 is received, receiver will send ACK 6.</p></li>
<li><p>If we had received 3 in the beginning, we would have immediately
sent ACK 4. This would also make the receiver move its window to
4,5,6.</p></li>
</ul>
<p>Example case:</p>
<figure>
<img src="../images/cn/sr.png" style="width:60.0%"
alt="Selective Repeat Example" />
<figcaption aria-hidden="true">Selective Repeat Example</figcaption>
</figure>
<h4 id="data-encoding-techniques">Data Encoding Techniques</h4>
<h5 id="nrz-unipolar">NRZ-Unipolar</h5>
<p>1 - +ve</p>
<p>0 - 0</p>
<h5 id="nrz-polar">NRZ-Polar</h5>
<p>1 - +ve</p>
<p>0 - -ve</p>
<h5 id="nrz-i">NRZ-I</h5>
<p>Differential Encoding.</p>
<p>1 - Signal transition at start (high-to-low or low-to-high)</p>
<p>0 - No signal transition at start</p>
<h5 id="manchester">Manchester</h5>
<p>Always has a mid-bit transition:</p>
<p>1 - Low to High</p>
<p>0 - High to Low</p>
<p>The start of the bit may also have a transition, if needed according
to the bit’s value.</p>
<p>For eg, if the bit is 1 (which means we need a low to high transition
in the middle), and the interval starts with a high value, we will
transition to low at the start.</p>
<p>(Eg - Encoding 11)</p>
<h5 id="differential-manchester">Differential Manchester</h5>
<p>Mid-bit transition is only for clocking purposes.</p>
<p>1 - Absence of transition at the start.</p>
<p>0 - Presence of transition at the start.</p>
<h5 id="bipolar-encoding">Bipolar Encoding</h5>
<p>1 - Alternating +1/2, -1/2 voltages</p>
<p>0 - 0 voltages</p>
<figure>
<img src="../images/cn/data_encoding.png"
alt="Data Encoding Techniques" />
<figcaption aria-hidden="true">Data Encoding Techniques</figcaption>
</figure>
<h2 id="media-access-sublayer">Media Access Sublayer</h2>
<p>The data link layer is divided into two sublayers.</p>
<ol type="1">
<li><strong>Media Access Control (MAC)</strong> - Defines the access
method for each LAN.</li>
<li><strong>Logical Link Control (LLC)</strong> - Flow control, Error
control, etc.</li>
</ol>
<p>Framing is handled by both.</p>
<h3 id="media-access-control-and-multiple-access-protocols">Media Access
Control and Multiple Access Protocols</h3>
<p>Handle how multiple nodes can communicate on a single link.</p>
<h3 id="random-access-contention-methods">Random Access/ Contention
Methods</h3>
<ul>
<li>All nodes are considered equal.</li>
<li>No scheduled transmission.</li>
<li>Transmission occurs randomly.</li>
<li>Nodes compete for access.</li>
</ul>
<h4 id="pure-aloha">Pure Aloha</h4>
<ul>
<li><p>Each node sends a frame when it has a frame to send.</p></li>
<li><p>Obviously, we will have collisions in case 2 nodes decide to send
a frame together.</p></li>
<li><p>Aloha expects the receiver of the frame to send ACK for the
frame.</p></li>
<li><p>Vulnerable time for Aloha is <span
class="math inline">\(2*T_t\)</span>. This is the time frame in which
collisions can happen.</p>
<p>For eg, A sent a frame at 12:05</p>
<p>Let transmission time = 5 minutes.</p>
<p>B wants to send a frame. But it cannot send a frame until 12:10,
because till 12:10 A will be transmitting its frame. A collision will
occur if B sends before 12:10.</p>
<p>Similarly, if C had earlier sent a frame anytime after 12:00, A’s
frame will collide with it.</p>
<p>Therefore, the vulnerable time is 12:00 - 12:10, which is 10 minutes
= twice of transmission time.</p></li>
<li><p>In case a collision occurs, the node waits a random amount of
time before retransmitting. How much time to wait is explained in the
flowchart below.</p></li>
<li><p>Maximum number of attempts are fixed.This value is called <span
class="math inline">\(K_{max}\)</span> For eg, if max attempts = 15, if
a node has transmitted the same frame 15 times and always gotten
collision, it will abort and try again some time later.</p></li>
<li><p><span class="math inline">\(K_{max}\)</span> is generally set to
be 15.</p></li>
</ul>
<p><strong>Efficiency of Pure Aloha</strong> <span
class="math display">\[ S = G.e^{-2G} \]</span></p>
<p>where <span class="math inline">\(G\)</span> is the the average
number of frames created by the <em>entire system</em> (all nodes
combined), during the transition time of a single frame.</p>
<p>For eg, if <span class="math inline">\(T_t\)</span> is 1ms, G is
number of frames produced per millisecond.</p>
<p><span class="math inline">\(S_{max}=0.184\)</span> at <span
class="math inline">\(G=1/2\)</span>.</p>
<figure>
<img src="../images/cn/aloha.png" alt="Flowchart for Aloha" />
<figcaption aria-hidden="true">Flowchart for Aloha</figcaption>
</figure>
<p>The procedure of choosing a random number between 0 and <span
class="math inline">\(2^K-1\)</span>, incrementing the value of K, and
waiting an amount of time based on R, is called the <strong>backoff
procedure.</strong></p>
<h4 id="slotted-aloha">Slotted Aloha</h4>
<ul>
<li>Same as Aloha, but time is divided into slots.</li>
<li>Frames can be sent <em>only at the beginning</em> of a time
slot.</li>
<li>Vulnerable Time = <span class="math inline">\(T_t\)</span></li>
</ul>
<p><strong>Efficiency of Slotted Aloha</strong> <span
class="math display">\[ S = G.e^{-G} \]</span></p>
<p><span class="math inline">\(S_{max}=0.368\)</span> at <span
class="math inline">\(G=1\)</span>.</p>
<h4 id="csma-carrier-sense-multiple-access">CSMA (Carrier Sense Multiple
Access)</h4>
<ul>
<li>Each node will sense the medium before sending.</li>
<li>If the medium is idle, send the data. Otherwise wait.</li>
<li>Collisions may still occur due to propagation delay.</li>
</ul>
<p>For e.g, if A sent a frame at 12:01, and propagation time from A to D
is 2 minutes. If D checks the medium at 12:02, it will find it idle and
send the frame. A’s frame and D’s frame will then collide.</p>
<ul>
<li>Vulnerable time = <span class="math inline">\(T_p\)</span> (Max
propagation time).</li>
</ul>
<h4 id="persistence-methods-for-csma">Persistence Methods for CSMA</h4>
<p>Persistence methods decide when and how to send data after sensing
medium.</p>
<h5 id="persistent">1-Persistent</h5>
<ul>
<li>Continuously Sense the medium.</li>
<li>As soon as the medium is idle, send the data immediately.</li>
</ul>
<h5 id="non-persistent">Non-Persistent</h5>
<ol type="1">
<li>If medium is idle, send the data immediately.</li>
<li>If medium busy, wait a random amount of time, then sense the medium
again and repeat from step 1.</li>
</ol>
<ul>
<li>Less efficient, as the channel may remain idle in the random waiting
time.</li>
<li>Less chance of collision.</li>
</ul>
<h5 id="p-persistent">P-Persistent</h5>
<p>Uses a value <span class="math inline">\(p\)</span> that is fixed by
the network administrator for each node. Different nodes have different
values of <span class="math inline">\(p\)</span></p>
<ol type="1">
<li>Continuously check medium till idle.</li>
<li>If idle:
<ul>
<li>Generate random number <span class="math inline">\(r\)</span></li>
<li>If <span class="math inline">\(r&lt;p\)</span>, then transmit the
data.</li>
<li>Else:
<ul>
<li>Wait for a time slot, and then check the line.</li>
<li>If line is idle, go to step 2.</li>
<li>If the line is busy, act as if a collision occurred, and follow the
backoff procedure.</li>
</ul></li>
</ul></li>
</ol>
<h4 id="csma-with-collision-detection-csmacd">CSMA with Collision
Detection (CSMA/CD)</h4>
<ul>
<li>Continue sensing medium for time= <span
class="math inline">\(2*T_p\)</span> after transmission.</li>
<li>This will help us sense potential collisions.</li>
<li>If a collision is detected, the node that detected the collision
will send a jamming signal to the access medium. After that, backoff
procedure will be applied.</li>
<li>Condition to detect collision: <span class="math display">\[
T_t=2*T_p \]</span> The transmission time for the frame should be long
enough that we can detect collisions while we are transmitting it.</li>
<li>Efficiency of CSMA/CD is<span class="math display">\[\eta =
\frac{1}{1+6.44a}\]</span> where <span
class="math inline">\(a=T_p/T_t\)</span>.</li>
</ul>
<h2 id="network-layer">Network Layer</h2>
<ul>
<li>Moves packet from source to destination</li>
<li>Uses routers, bridges, switches.</li>
<li>Deals with IP addresses.</li>
</ul>
<p>Performs the following functions:</p>
<ul>
<li>Routing</li>
<li>Fragmentation</li>
<li>Congestion Control</li>
</ul>
<p>IP addresses have two parts - network ID, and host ID. Network ID
represents which network the IP address is part of, i.e, which
organization controls it. Host ID represents which <em>computer</em> (or
mobile,printer,etc.) in that network the IP address belongs to.</p>
<p>For e.g, Google has many servers. They will all have the same Network
ID, but different Host IDs.</p>
<h3 id="classful-addressing">Classful Addressing</h3>
<p>IPv4 addresses were divided into various classes for easier
addressing purposes.</p>
<p>An IPv4 address is a 32-bit address. For ease of representation, it
is divided into 4 octets. Each octet contains 8-bits.</p>
<p>(8)(8)(8)(8)</p>
<p>It allows us to write the IP address in the following format -
192.168.10.1 Here, 192 is the first octet, 168 is the second, and so on.
All are represented in decimal. This is called Dotted Decimal
Representation.</p>
<h4 id="class-a">Class A</h4>
<p>In this, the first bit of the first octet is always fixed as 0.</p>
<pre><code>0 _ _ _ _ _ _ _ . (octet 2) . (octet 3) . (octet 4)</code></pre>
<p>The range of the first octet becomes <code>00000000</code> to
<code>01111111</code>, i.e. 0 to 127.</p>
<p>The 1st octet represents the Network ID (7-bits).</p>
<p>The 2nd, 3rd and 4th octet represent the Host ID (24-bits).</p>
<p><strong>Number of IP Addresses in Class A</strong> = <span
class="math inline">\(2^{31}\)</span>, which is half of all IPv4
Addresses in the world.</p>
<p><strong>Total number of Networks</strong> = <span
class="math inline">\(2^7-2 = 126\)</span>. Range is [1,126].</p>
<p>The network IDs 00000000 and 01111111 are reserved and unused. They
aren’t given to any organization.</p>
<p><strong>Total number of hosts in each Network</strong> = <span
class="math inline">\(2^{24}-2\)</span></p>
<p>Host with values 0.0.0 and 255.255.255 (first and last hosts) are
also reserved and unused.</p>
<p>The host with value 0.0.0 is used to represent the entire network.
So, for a network with networkID = 28, 28.0.0.0 is used to represent the
entire network (and not any particular host in the network).</p>
<p>Host with value 255.255.255 is used to represent Direct Broadcast
Address. If anyone wants to send a particular message to <em>all</em>
the hosts in a network, they will use this. For a network with networkID
=28, 28.255.255.255 represents its direct broadcast address.</p>
<p><strong>Default Mask</strong> for class A is 255.0.0.0</p>
<p><strong>For any IP address, performing bitwise AND of the IP Address,
and the Default Mask for its class will give us the network that IP
address belongs to</strong>.</p>
<p>For eg, let the IP address be 28.12.34.1</p>
<p>First bit of first octet is 0, so we know it’s a class A Address.</p>
<p>Bitwise AND with 255.0.0.0</p>
<pre><code>00011100.00001100.00100010.00000001 (28.12.34.1)
11111111.00000000.00000000.00000000
-----------------------------------
00011100.00000000.00000000.00000000

= 28.0.0.0</code></pre>
<p>28.0.0.0 represents the network that the IP address 28.12.34.1
belongs to.</p>
<hr />
<h4 id="class-b">Class B</h4>
<p>First octet has first 2 bits fixed as <code>10</code></p>
<pre><code>1 0 _ _ _ _ _ _ . (octet 2) . (octet 3) . (octet 4)</code></pre>
<p>First 2 octets represent the Network ID.</p>
<p>Last 2 octets represent the Host ID.</p>
<p><strong>Range</strong> is (128-191)</p>
<p><strong>Number of IP Addresses</strong> = <span
class="math inline">\(2^{30}\)</span>, 25% of all IPv4 addresses in the
world.</p>
<p><strong>Number of networks</strong> = <span
class="math inline">\(2^{14}\)</span></p>
<p><strong>Number of hosts in each network</strong> = <span
class="math inline">\(2^{16}-2 = 65534\)</span></p>
<p>First and last hosts are excluded here, as they were in class A.</p>
<p><strong><em>Class A excluded first and last networks also. Class B
excludes first and last hosts only. All networks in Class B are
available for use.</em></strong></p>
<p><strong>Default Mask</strong> - 255.255.0.0.</p>
<hr />
<h4 id="class-c">Class C</h4>
<p>First octet has first 3 bits fixed as <code>110</code></p>
<pre><code>1 1 0 _ _ _ _ _ . (octet 2) . (octet 3) . (octet 4)</code></pre>
<p>First 3 octets represent the Network ID.</p>
<p>Last octet represent the Host ID.</p>
<p><strong>Range</strong> is (192-223)</p>
<p><strong>Number of IP Addresses</strong> = <span
class="math inline">\(2^{29}\)</span>, 12.5% of all IPv4 addresses in
the world.</p>
<p><strong>Number of networks</strong> = <span
class="math inline">\(2^{21}\)</span></p>
<p><strong>Number of hosts in each network</strong> = <span
class="math inline">\(2^8-2 = 254\)</span></p>
<p>First and last hosts are excluded here, as they were in class A.</p>
<p><strong><em>Class A excluded first and last networks also. Class C
excludes first and last hosts only. All networks in Class C are
available for use.</em></strong></p>
<p><strong>Default Mask</strong> - 255.255.255.0.</p>
<h4 id="class-d">Class D</h4>
<p>First Octet has first 4 bits reserved as <code>1110</code></p>
<pre><code>1 1 1 0 _ _ _ _ . (octet 2) . (octet 3) . (octet 4)</code></pre>
<p><strong>Range</strong> is (224-239)</p>
<p><strong>Number of IP Addresses</strong> = <span
class="math inline">\(2^{28}\)</span></p>
<p>In class D, all IP addresses are reserved. There is no network ID and
no host ID.</p>
<p>These IP addresses are only meant to be used for multicasting, group
email, broadcasting, etc.</p>
<hr />
<h4 id="class-e">Class E</h4>
<p>First Octet has first 4 bits reserved as <code>1111</code></p>
<pre><code>1 1 1 1 _ _ _ _ . (octet 2) . (octet 3) . (octet 4)</code></pre>
<p><strong>Range</strong> is (240-255)</p>
<p><strong>Number of IP Addresses</strong> = <span
class="math inline">\(2^{28}\)</span></p>
<p>All IP addresses are reserved for military purposes.</p>
<hr />
<h3 id="classless-addressing">Classless Addressing</h3>
<p>This divides 32-bit IP addresses into BlockID and HostID.</p>
<p>BlockID is similar to NetworkID.</p>
<p><strong>Format</strong> - x.y.z.w/n</p>
<p><span class="math inline">\(n\)</span> represents the number of bits
used to represent the blockID.</p>
<p>It also represents the number of 1-bits that the mask for this IP
address should have.</p>
<p>For e.g - 128.225.1.1/10</p>
<p>This means the first 10 bits represent the block ID, and rest 22 bits
specify host ID.</p>
<p>The mask for this network would be -
<code>11111111.11000000.00000000.00000000</code>, (10 times 1, then all
0)</p>
<p>To find the network, we do bitwise AND of IP address and mask</p>
<pre><code>10000000.11100001.00000001.00000001
11111111.11000000.00000000.00000000
-----------------------------------
10000000.11000000.00000000.00000000

= 128.192.0.0</code></pre>
<p>The network that IP address belongs to is 128.192.0.0/10</p>
<h4 id="rules-for-classless-addressing">Rules for Classless
Addressing</h4>
<ul>
<li><p>Addresses should be contiguous</p></li>
<li><p>Number of addresses must be in power of 2.</p></li>
<li><p>1st address of every block must be evenly divisible by block size
(number of hosts)</p>
<p>Block Size = number of hosts = <span
class="math inline">\(2^{32-10}=2^22\)</span> First address of block is
same as network’s IP address = 128.192.0.0/10 =
10000000.11000000.00000000.00000000 =
10000000110000000000000000000000</p>
<p>We don’t need to divide. We can just check that the last 22 (22 is
number of bits used to specify host) bits are 0.</p>
<p>i.e, the 22 least significant bits (LSBs) should be 0, which is true
in our case.</p></li>
</ul>
<h3 id="subnetting">Subnetting</h3>
<p>Subnetting is the process of dividing a large network into smaller
<em>subnets</em>. This helps in organization, security, fixing bugs,
etc.</p>
<p>An organization may divide it’s network into separate subnets for
finance department, legal department, etc.</p>
<p>We do this by dividing the hosts.</p>
<p><strong><em>NetworkID REMAINS UNCHANGED IN SUBNETTING,
ALWAYS.</em></strong></p>
<h4 id="subnetting-in-classful-addressing">Subnetting in Classful
Addressing</h4>
<p>Suppose we have a network with the IP <code>200.10.20.0</code>. This
is a Class C IP address.</p>
<p>It has a total of 254 hosts. We want to divide it into 2 equal
subnets.</p>
<ul>
<li>Network ID is 200.10.20. This will remain unchanged.</li>
<li>The last octet is used to specify the host. Let’s say we want 2
subnets - <span class="math inline">\(S_1\)</span> and <span
class="math inline">\(S_2\)</span>.</li>
<li>We will subnet by fixing the first bit in the last octet as either 1
or 0.</li>
</ul>
<h5 id="s_1"><span class="math inline">\(S_1\)</span></h5>
<p>For the last octet, we will prefix the first bit for <span
class="math inline">\(S_1\)</span> as <code>1</code>.</p>
<p><span class="math inline">\(S_1\)</span> will have IP addresses of
the form <code>200.10.20.1 _ _ _ _ _ _ _</code>.</p>
<p><strong>Range</strong> =&gt; 200.10.20.128 - 200.10.20.255</p>
<p><strong>Usable IP addresses</strong> = <span
class="math inline">\(2^7-2 = 126\)</span></p>
<p><strong>Network IP address</strong> for <span
class="math inline">\(S_1\)</span> is 200.10.20.128.</p>
<p><strong>Broadcast IP address</strong> is 200.10.20.255</p>
<h5 id="s_2"><span class="math inline">\(S_2\)</span></h5>
<p>For the last octet, we will prefix the first bit for <span
class="math inline">\(S_2\)</span> as <code>0</code>.</p>
<p><span class="math inline">\(S_2\)</span> will have IP addresses of
the form <code>200.10.20.0 _ _ _ _ _ _ _</code>.</p>
<p><strong>Range</strong> =&gt; 200.10.20.0 - 200.10.20.127</p>
<p><strong>Usable IP addresses</strong> = <span
class="math inline">\(2^7-2 = 126\)</span></p>
<p><strong>Network IP address</strong> for <span
class="math inline">\(S_1\)</span> is 200.10.20.0.</p>
<p><strong>Broadcast IP address</strong> is 200.10.20.127</p>
<p>Thus, if the network receives a packet meant for 200.10.20.50, it
will be sent to <span class="math inline">\(S_2\)</span>.</p>
<p>A packet meant for 200.10.20.165 will be sent to <span
class="math inline">\(S_1\)</span>.</p>
<h5 id="subnet-mask">Subnet Mask</h5>
<p>Since we are indirectly using 1 extra bit to specify Network ID now,
our subnet mask will also have 1 extra bit added to it.</p>
<p>Class C’s Subnet mask is 255.255.255.0</p>
<p>Now, it will be <code>255.255.255.1 _ _ _ _ _ _ _</code>.</p>
<p>We added 1 in the place where we prefixed an extra bit.</p>
<p>Subnet mask for our network is now 255.255.255.128</p>
<hr />
<p>Our total number of usable IP addresses has become 126+126= 252.
Earlier, it was 254.</p>
<p>Due to subnetting, we have lost the use of 2 IP addresses.</p>
<p><strong>Number of usable IP addresses</strong> = Number Of Original
Usable IP Addresses - <span class="math inline">\(n*2\)</span></p>
<p>where <span class="math inline">\(n\)</span> is the number of
subnets.</p>
<h4 id="subnetting-in-classless-addressing">Subnetting in Classless
Addressing</h4>
<p>The procedure is mostly the same as for subnetting in classful
addressing. The only extra thing that needs to be done is to change the
value of <span class="math inline">\(n\)</span>.</p>
<p>For.eg,</p>
<p>128.192.0.0/10 - let this be our network.</p>
<p>First 10 bits specify block. Last 22 bits specify host.</p>
<p><strong>10000000.11</strong>000000.00000000.00000000. The bold part
represents block ID.</p>
<p>To subnet into two equal subnets, we fix the first host-bit.</p>
<p>Subnet 1 will have IP addresses of the form 10000000.111<em>0</em>_ _
_ _ ._ _ _ _ _ _ _ _ ._ _ _ _ _ _ _ _. (We prefixed 0)</p>
<p>Subnet 2 will have IP addresses of the form 10000000.111<em>1</em>_ _
_ _ ._ _ _ _ _ _ _ _ ._ _ _ _ _ _ _ _. (We prefixed 1)</p>
<p>To find out IP Addresses for Subnet1 and Subnet2, we will have to
increase the value of <span class="math inline">\(n\)</span> by 1, since
now we are using an extra bit to find out block ID.</p>
<p><strong>Subnet1 IP Address</strong> = 128.192.0.0/11</p>
<p><strong>Subnet2 IP Address</strong> = 128.224.0.0/11</p>
<p>Accordingly, mask will be changed.</p>
<h4 id="variable-length-subnet-masking-vlsm">Variable Length Subnet
Masking (VLSM)</h4>
<p>In case we want subnets of different sizes, we use this technique. It
works for both classless and classful addressing in similar ways. We’ll
explain using classful here.</p>
<p>Suppose we have a network with IP 200.10.20.0.</p>
<p>We want to divide it into 3 networks - <span
class="math inline">\(S_1,S_2,S_3\)</span>. <span
class="math inline">\(S_1\)</span> should have 50% of all hosts. <span
class="math inline">\(S_2\)</span> and <span
class="math inline">\(S_3\)</span> should have 25% each.</p>
<p>We will subnet in the following way:</p>
<h5 id="s_1-1"><span class="math inline">\(S_1\)</span></h5>
<p><strong>IP Addresses of the form</strong> - 200.10.20.0 _ _ _ _ _ _ _
(1 bit prefixed)</p>
<p><strong>Range</strong> - 200.10.20.0 - 200.10.20.127</p>
<p><strong>Usable IP Addresses</strong> - 126</p>
<h5 id="s_2-1"><span class="math inline">\(S_2\)</span></h5>
<p><strong>IP Addresses of the form</strong> - 200.10.20.1 0 _ _ _ _ _ _
(2 bits prefixed)</p>
<p><strong>Range</strong> - 200.10.20.128 - 200.10.20.191</p>
<p><strong>Usable IP Addresses</strong> - 62</p>
<h5 id="s_3"><span class="math inline">\(S_3\)</span></h5>
<p><strong>IP Addresses of the form</strong> - 200.10.20.1 1 _ _ _ _ _ _
(2 bits prefixed)</p>
<p><strong>Range</strong> - 200.10.20.192 - 200.10.20.255</p>
<p><strong>Usable IP Addresses</strong> - 62</p>
<p>For <span class="math inline">\(S_1\)</span>, we prefixed only 1 bit.
For <span class="math inline">\(S_2\)</span> and <span
class="math inline">\(S_3\)</span> we prefixed two bits. We can see that
the <span class="math inline">\(S_1\)</span> has roughly double the
number of IP addresses that <span class="math inline">\(S_2\)</span> and
<span class="math inline">\(S_3\)</span> each have.</p>
<p>We divided the network into two equal halves - <span
class="math inline">\(S_1\)</span>, and let’s call the other part <span
class="math inline">\(S&#39;\)</span>.</p>
<p>Then, we further divided <span class="math inline">\(S&#39;\)</span>
into <span class="math inline">\(S_2\)</span> and <span
class="math inline">\(S_3\)</span>.</p>
<figure>
<img src="../images/cn/subnet.png" alt="VLSM" />
<figcaption aria-hidden="true">VLSM</figcaption>
</figure>
<h3 id="header-formats-for-ip-protocols">Header Formats for IP
Protocols</h3>
<p>Whenever a packet is sent using IP (IPv4 or IPv6), it includes data
(payload), as well as a header. The header doesn’t contain the actual
data, but it contains metadata such as destination, priority, source,
etc.</p>
<h4 id="ipv4-header-format">IPv4 Header Format</h4>
<ul>
<li>IPv4 is a <a href="#connectionless">connectionless</a> <a
href="#switched-networks">datagram</a> service.</li>
<li>Header size is between 20-60 bytes.</li>
<li>The total datagram size is at max 64 KB, or 65535 bytes.</li>
<li>The payload size is maximum 65515 bytes. This happens when the
header size is 20 bytes. In case the header size is larger than 20, the
max payload size will be decreased accordingly.</li>
</ul>
<figure>
<img src="../images/cn/ipv4.png" alt="IPv4 Header Format" />
<figcaption aria-hidden="true">IPv4 Header Format</figcaption>
</figure>
<h5 id="ver">VER</h5>
<ul>
<li><p>Stands for version. It is a 4-bit value. It contains the value of
version, i.e, which IP version is being used.</p></li>
<li><p>Almost all transmissions either use IPv4 or IPv6.</p></li>
<li><p>Version for IPv4 is 4 = 0100</p></li>
<li><p>Version for IPv6 is 6 = 0110</p></li>
</ul>
<h5 id="hlen">HLEN</h5>
<ul>
<li>Contains the header-length.</li>
<li>4-bit value.</li>
<li>Uses a factor of 4.</li>
</ul>
<p>Header size = HLEN*4.</p>
<p>As the minimum header size for IPv4 is 20 bytes, HLEN can never be
0,1,2,3 or 4.</p>
<h5 id="type-of-service">Type of Service</h5>
<ul>
<li>Also known as DSCP (Differentiated Service Code Point)</li>
<li>8-bit value</li>
<li>Contains different values specifying the type of service we wish to
use.</li>
</ul>
<p>The 8 bits are:</p>
<p><code>[P][P][P][D][T][R][C][0]</code></p>
<p>The first 3 bits (P) are used to set the precedence, or priority of
the packet.</p>
<p><em>D - Delay.</em></p>
<p>0 means normal delay. 1 tells router this packet needs minimal
delay.</p>
<p><em>T- Throughput</em></p>
<p>0 - normal</p>
<p>1 - maximize</p>
<p><em>R - Reliability</em></p>
<p>0 - normal</p>
<p>1 - maximize</p>
<p><em>C - Cost</em></p>
<p>0 - normal</p>
<p>1 - minimize</p>
<p>The last value is reserved as 0. It’s fixed for future use. Only one
bit out of D,T,R and C can be 1 in a packet. More than 1 cannot be 1.
For eg - 0011 is not valid.</p>
<h5 id="total-length">Total Length</h5>
<p>Contains total length of the packet. 16-bit value.</p>
<h5 id="ttl-time-to-live">TTL (Time to Live)</h5>
<ul>
<li>8-bit value</li>
<li>Source sets it to max value (255), or it can also be set as (max
number of routers between source and destination)*2.</li>
<li>At each node it encounters (router/switch/etc.), the value is
reduced by 1.</li>
<li>When it becomes 0, the packet is dropped.</li>
<li>This helps in case a packet is getting stuck in loops in the
network, causing congestion.</li>
</ul>
<h5 id="protocol">Protocol</h5>
<ul>
<li>8-bit</li>
<li>Tells which protocol is being used, TCP,UDP, etc.</li>
</ul>
<h5 id="header-checksum">Header Checksum</h5>
<ul>
<li>Contains the checksum value for the header.</li>
<li>16-bit</li>
<li>Only IP header fields are used while calculating checksum, actual
data isn’t used. This is because higher level protocols such as TCP and
UDP use their own checksums for the data, so it isn’t required for IP to
do it as well.</li>
<li>Since fields like TTL can change, header checksum is recalculated at
each router.</li>
</ul>
<h5 id="source-ip">Source IP</h5>
<ul>
<li>Contains IP address of the source</li>
<li>32-bit</li>
</ul>
<h5 id="destination-ip">Destination IP</h5>
<ul>
<li>Contains IP address of destination.</li>
<li>32-bit</li>
</ul>
<hr />
<p>Fragmentation is done for packets that are larger in size than the
permitted size.</p>
<p>The packet is broken down into many smaller packets, then sent over
the network. It is reassembled at the source.</p>
<p>The IPv4 header contains values to identify the fragments.</p>
<h5 id="identification-bits">Identification Bits</h5>
<p>This is a 16-bit unique packet ID. It identifies a group of fragments
that belong to a single IP datagram.</p>
<h5 id="flag">Flag</h5>
<p>3-bit value.</p>
<p><code>[R][D][M]</code></p>
<p>The first bit is reserved as 0.</p>
<p>The second bit (D) stands for <strong>Do not Fragment</strong>. If
this bit is 1, no node will try to fragment this bit. But, if some node
doesn’t allow a packet of a large size, and we set D=1, the node may
drop that packet altogether.</p>
<p>The third bit (M) stands for <strong>More Fragments</strong></p>
<p>If M=0, either this packet is the last packet in its datagram, ot
it’s the only fragment.</p>
<p>If M=1, it means more fragments are coming after this packet.</p>
<h5 id="fragment-offset">Fragment Offset</h5>
<p>This represents the number of data bytes ahead of this particular
fragment, i.e, the position of this fragment in the original
unfragmented datagram.</p>
<p>It uses a factor of 8.</p>
<p>I.e, number of bytes ahead = Fragment Offset * 8.</p>
<p>For eg, if a datagram is broken into 4 fragments of 80 bytes each
(excluding the header length).</p>
<p>Fragment offset value for</p>
<p>1st fragment - 0 (No bytes ahead of it)</p>
<p>2nd fragment - 10 (80 bytes of data ahead of it. 80/8=10)</p>
<p>3rd fragment - 20</p>
<p>4th fragment - 30</p>
<h5 id="options">Options</h5>
<p>These contain optional headers and metadata. For example, they may
be:</p>
<h6 id="record-route">Record Route</h6>
<p>Tells the nodes to record the route this packet has taken in the
header. Can record upto 9 router addresses.</p>
<h6 id="source-routing">Source routing</h6>
<p>The source defines the route that the packet will take.</p>
<p>Users cannot set source routing, only routers are allowed to do
this.</p>
<h6 id="padding">Padding</h6>
<p>This is added in case the header size is not in multiple of 4.</p>
<p>We need to store the header length in HLEN, which uses a factor of
4.</p>
<p>So, if the header length is 21, we will add 3 bytes of padding to
make it 24. Then HLEN will store 24/4 = 6.</p>
<h4 id="ipv6-header">IPv6 Header</h4>
<ul>
<li>IPv6 uses 128-bit IP addresses instead of 32-bit.</li>
<li>Only source can fragment packets. Intermediate nodes cannot.</li>
<li>Header length is fixed at 40 bytes.</li>
</ul>
<figure>
<img src="../images/cn/ipv6.png"
alt="IPv6 Header. Length of fields written in brackets." />
<figcaption aria-hidden="true">IPv6 Header. Length of fields written in
brackets.</figcaption>
</figure>
<p><strong>VER</strong> is the same as in IPv4.</p>
<p><strong>Traffic Type</strong> is the same as Type of Service in
IPv4.</p>
<h5 id="flow-label">Flow Label</h5>
<p>20-bit value.</p>
<p>For continuous data that travels in a flow, such as video streaming,
or live updates, we use flow labels. Even large files may be sent using
flows. A source and a destination may have multiple flows occurring
between them.</p>
<p>For e.g, if you’re downloading two files together from Google Drive,
they may be sent through 2 different flows. So, we give them different
flow labels to help identify which flow is which.</p>
<h5 id="payload-length">Payload Length</h5>
<p>Length of the payload</p>
<h5 id="next-header">Next Header</h5>
<p>IPv6 uses extension headers instead of options. Metadata for routing,
authentication, fragmentation, etc. are set in special extension
headers.</p>
<p>This field is a 8-bit field that contains the type of the extension
header (if present), that comes immediately after the IPv6 header. Each
extension header contains its own “Next Header” field. The extension
headers are thus chained together like this.</p>
<p><img src="../images/cn/ipv6next.png" /></p>
<p>In some cases, this field is also used to indicate protocols in upper
layers, such as TCP or UDP.</p>
<h5 id="hop-limit">Hop Limit</h5>
<p>Same as TTL in IPv4 Header</p>
<p><strong>Source IP</strong> and <strong>Destination IP</strong> are
128-bit IPv6 addresses for the source and destination respectively.</p>
<h5 id="extension-headers">Extension Headers</h5>
<p>Extension headers may be used for many purposes. Some common
extension headers used in IPv6 are:</p>
<ul>
<li>Routing headers, used if source wants to determine the route the
packet should take.</li>
<li>Authentication headers, used for security purposes.</li>
<li>Fragmentation Header, used for fragments.</li>
</ul>
<h3 id="routing-protocols">Routing Protocols</h3>
<p>Routing Protocols are used to decide the route a particular packet
will take to its destination.</p>
<h4 id="distance-vector-routing-dvr">Distance Vector Routing (DVR)</h4>
<ul>
<li>Each node maintains table of minimum distance to <em>every</em>
other node in the network.</li>
<li>Information is shared only between neighbors (directly connected).
Each node will share its routing table to its immediate neighbours.</li>
<li>Update may be <strong>periodic</strong> or
<strong>triggered</strong>.</li>
<li>Count to Infinity problem may occur in this.
<ul>
<li>Three nodes - X—A—B. X-A = 1, A-B=1, X-A=2</li>
<li>If link between X and A breaks, then the following problem will
occur. A will set its distance to X as infinity.</li>
<li>B will send its routing table to A. A will think B has found another
path to X with cost 2. It will update its routing table so that
X-A=2+1=3</li>
<li>A will send new table to B. B will think the cost to get to X
(through A) has increased to 3. It will update its table so that
X-B=4.</li>
<li>Similarly, B will again send the new table to A. A will update the
X-A value to 5. This process will continue forever.</li>
</ul></li>
<li>Bellman Ford is used to calculate distance tables.</li>
</ul>
<h4 id="link-state-routing">Link State Routing</h4>
<ul>
<li>Router sends information about its neighbors to the entire network
through flooding.</li>
<li>Uses Dijsktra to calculate routing tables.</li>
<li>Hello messages are sent to discover neighbor nodes.</li>
</ul>
<h2 id="transport-layer">Transport Layer</h2>
<h3 id="responsibilities">Responsibilities</h3>
<ul>
<li><p><strong>Port to Port Delivery/ Process to Process
Delivery.</strong> It must deliver the data from the sender application
(for e.g, a browser) to the receiver application (the server of the
website the user opened).</p></li>
<li><p><strong>Segmentation</strong> - Break down the data into smaller
parts that can be sent over the network, and reassemble it at the
receiver side.</p></li>
<li><p><strong>Multiplexing and Demultiplexing</strong> - A single
device generally only has a single connection to the Internet (or any
other network). If multiple applications are using that connection,
multiplexing and demultiplexing of data is done.</p></li>
<li><p><strong>Connection Management</strong></p></li>
<li><p><strong>Reliability</strong> - All the data must be delivered to
the receiver correctly. No lost/corrupted data should be delivered.
Lost/corrupted data must be detected and resent. <strong>UDP doesn’t
provide reliability.</strong></p></li>
<li><p><strong>Order</strong> - Data must be sent in order. If the data
was broken down into 4 parts, they must arrive in the correct order.
<strong>UDP doesn’t provide in-order delivery.</strong></p></li>
<li><p><strong>Error Control</strong> - Checksums are used for this.
Receiver verifies the checksum that the sender sent.</p></li>
<li><p><strong>Congestion Control</strong></p></li>
<li><p><strong>Flow Control</strong></p></li>
</ul>
<h3 id="socket-address-and-port-numbers">Socket Address and Port
Numbers</h3>
<p>Socket Addresses are made up of an IP address, and a 16-bit port
number. They are used to uniquely identify a TCP/UDP/ any other
transport layer protocol connection.</p>
<p>A particular computer will have an IP address, but many applications
running on it may need to access the Internet. When data packets arrive,
the OS must be able to figure out which data packet belongs to which
application.</p>
<p>A unique port number is assigned to each application. Only one
application may use a particular port at a given time. For e.g, two
applications cannot listen on port 3000 at the same time.</p>
<h4 id="port-number-types">Port Number Types</h4>
<p>There are three categories of port numbers:</p>
<ol type="1">
<li><p><strong>Well Known/System Ports</strong> - These are the ports
for most commonly used networking tasks. For example, a web-server will
always listen for HTTP requests on Port 80, and HTTPS on port 443.
Typing www.google.com in a browser is the same as typing
www.google.com:443, because the browser knows that the standard port for
HTTPS is 443.</p>
<p>Range for these is 0-1023.</p></li>
<li><p><strong>Registered/User Ports</strong> - Organizations and
Applications can have specific ports reserved for their use. They can
register these with IANA (Internet Assigned Numbers Authority). For e.g,
Xbox Live has 3074 port number reserved for it.</p>
<p>Range for these is 1025-49151.</p></li>
<li><p><strong>Dynamic/Ephemeral Ports</strong> - These are the rest of
the ports left in the range. When an application needs to use a
transport layer protocol, it requires a port number. The OS will
generally assign it any random port number that is currently not in
use.</p>
<p>Range for these is 49152-65535</p></li>
</ol>
<p><strong><em>IP Address is used to differentiate one machine from
another. Port Numbers are used to differentiate different applications
on the same machine.</em></strong></p>
<h3 id="tcp-transmission-control-protocol">TCP (Transmission Control
Protocol)</h3>
<p>TCP (Transmission Control Protocol) is a popular transport layer
protocol. Most applications, such as HTTP, HTTPS, Email (SMTP/IMAP),
etc. use TCP.</p>
<h4 id="characteristics">Characteristics</h4>
<p>Characteristics of TCP are:</p>
<ol type="1">
<li><strong>Byte Streaming</strong> - Application layer continuously
sends data to the transport layer. TCP breaks it down into bytes, and
packages several bytes into a single <strong>segment</strong>. Multiple
segments are created and sent to the receiver.</li>
<li><strong>Connection-Oriented</strong> - TCP establishes a connection
with the receiver first, using a 3-way handshake. All future
communication between sender and receiver occurs over this
connection.</li>
<li><strong>Full Duplex</strong> - Two-way communication can happen, at
the same time.</li>
<li><strong>Piggybacking</strong> - Sender sends data to receiver, and
receiver must send back acknowledgement for that data. In most cases
these days, communication occurs both ways, i.e, if A sends data to B, B
also sends data to A. Thus, instead of B sending acknowledgements
separately to A, B will attach the acknowledgement along with the data
it has to send A.</li>
<li><strong>Needs buffers</strong> - Sending and receiving processes may
not operate at same speed, therefore TCP needs sender and receiver
buffers for storage.</li>
</ol>
<h4 id="tcp-header">TCP Header</h4>
<figure>
<img src="../images/cn/tcpheader.jpg" alt="TCP Header" />
<figcaption aria-hidden="true">TCP Header</figcaption>
</figure>
<p>TCP Header is attached to each TCP Segment. It contains the following
fields. It’s size can vary from 20-60 bytes.</p>
<h5 id="source-port">Source Port</h5>
<p>Port Number for the source (sender) application.</p>
<h5 id="destination-port">Destination Port</h5>
<p>Port Number for the destination (receiver) application.</p>
<h5 id="sequence-number">Sequence Number</h5>
<p>Each segment is given a sequence number based on the data sent before
it. When a TCP connection is established, a random sequence number is
generated.</p>
<p>For e.g, let the initial sequence number be 500.</p>
<p>Let’s say A sends B 200 bytes of data, in 4 segments of size 50
bytes. The sequence number will be 500 for the first segment, 550 for
the second segment, 600 for the third, and so on.</p>
<h5 id="acknowledgment-number">Acknowledgment Number</h5>
<p>This is used to let the sender know that the packet that it sent has
been received. It is set as the value of the next sequence number that
the receiver is expecting.</p>
<p>For e.g, if A sends B data with sequence number 500, that has 50
bytes in it. Thus, B receives bytes number 500,501,502….549. Now, it
expects byte number 550. Thus, it will set Acknowledgement Number as
550.</p>
<h5 id="header-lengthdata-offset">Header Length/Data Offset</h5>
<p>Length of the TCP Header. Uses a factor of 4, same as <a
href="#hlen">IPv4 Header’s HLEN field</a></p>
<h5 id="reserved">Reserved</h5>
<p>Next 6 bits are reserved for future use. 2 of them have already been
defined as CWR and ECE.</p>
<h5 id="code-bitsflag-bits">Code-Bits/Flag Bits</h5>
<p>There are 6 Flag Bits, each with their own purpose.</p>
<h6 id="urg-urgent">URG (Urgent)</h6>
<p>If this bit is set to 1, it means that this segment contains urgent
data. Location of the urgent data is set in the <a
href="#urgent-field">urgent pointer</a>.</p>
<h6 id="ack">ACK</h6>
<p>Indicates that this message contains an acknowledgement, i.e, the
value of the <a href="#acknowledgment-number">acknowledgement number</a>
is significant.</p>
<h6 id="psh-push">PSH (Push)</h6>
<p>When receiver is receiving data, it will generally buffer some amount
of data before sending it to the application layer. PSH field indicates
that the receiver should stop buffering and push whatever data it has to
the application layer.</p>
<h6 id="rst-reset">RST (Reset)</h6>
<p>Used to Reset the TCP connection.</p>
<h6 id="syn-sync">SYN (Sync)</h6>
<p>Used to sync sequence numbers. Only the first packet sent from each
end should have this value set.</p>
<h6 id="fin-finish">FIN (Finish)</h6>
<p>Used to terminate the connection.</p>
<h5 id="window-size">Window Size</h5>
<p>Specifies the size of the receiver’s window, i.e, the current amount
of data it is willing to receive. A will tell its window size to B, and
B will tell its window size to A.</p>
<h5 id="checksum">Checksum</h5>
<p>Used for error-checking.</p>
<h5 id="urgent-field">Urgent Field</h5>
<p>If the segment contains urgent data, this field tells <em>where</em>
the urgent data is located. It contains the sequence number of the
<em>last</em> urgent byte. For eg, if A sent bytes number 500-549, and
bytes 500-520 are urgent, the urgent field will contain the value
520.</p>
<h5 id="options-1">Options</h5>
<p>Contains optional fields, such as timestamps, window scale, and
<strong>maximum segment size (MSS)</strong>. MSS is the maximum size of
<strong>one</strong> single segment that the receiver is willing to
accept. It is separate from window size, which may be larger, as a
window can contain multiple segments.</p>
<h5 id="padding-1">Padding</h5>
<p>In case the total header size is not a multiple of 4, we add empty
zeroes to make it so, so that we can store it in the <a
href="#header-length/data-offset">header length</a> field.</p>
<h4 id="tcp-connection-establishment">TCP Connection Establishment</h4>
<p>A 3-way handshake is used to establish a TCP connection. This process
occurs before any actual data is sent. The 3 steps are:</p>
<ol type="1">
<li><p><strong>SYN</strong> - Sender will send the receiver a connection
request. It will send a randomly generated sequence number,its port
number, its window size, etc. It will set the SYN flag as 1, indicating
that it wants to set up a connection.</p>
<p>Let’s say A sent a connection request to B, with the sequence number
3000 (random), and window size as 1200 bytes. This will let B know that
A only can only receive 1200 bytes of data (until it empties its buffer
again)</p></li>
<li><p><strong>SYN-ACK</strong> - The receiver will respond to the
sender’s request. It will send a response, with SYN field as 1. It will
also send an acknowledgement (in the same response), and tell its own
window size to the sender.</p>
<p>B will reply to A. It will generate a random sequence number, say
5000. It will set the ACK and SYN flag. It will also set the
acknowledgement number to 3001 (since A’s sequence number was 3000.) It
sends A its window size, say 800 bytes.</p></li>
<li><p><strong>ACK</strong> - Sender will acknowledge the response.
After this, sender and receiver will begin exchanging actual data. SYN
flag is 0 in this.</p>
<p>A will send B a response with sequence number 3001, and
Acknowledgment number 5001. ACK will be set as 1. SYN flag will be
0.</p></li>
</ol>
<blockquote>
<p>Sequence numbers are not consumed if PURE ACK is sent. If a segment
contains only ACK, and not data, and it uses sequence number <span
class="math inline">\(x\)</span>, then the next segment can also use
sequence number <span class="math inline">\(x\)</span>.</p>
</blockquote>
<p>After this, A and B can start exchanging data. Both A and B will
reserve some resources (memory, RAM, etc.) for this A-B TCP
connection.</p>
<p>A will not send more than 800 bytes to B, and B will not send more
than 1200 bytes to A. A will send sequence numbers 3002,3003,3004…., and
B will send sequence numbers 5001,5002,5003… and so on.</p>
<h4 id="tcp-connection-termination">TCP Connection Termination</h4>
<p>4-way handshake.</p>
<ol type="1">
<li><p><strong>FIN from Client</strong>- Client wants to close the
connection. Client will send server a segment with FIN bit as 1. (Server
may also choose to close the connection)</p>
<p>Client will enter <strong>FIN_WAIT_1</strong> state. In this state,
the client waits for an ACK from the server for this FIN segment. This
is also called <strong>Active Close</strong> state.</p></li>
<li><p><strong>ACK From Server</strong>- Server will receive the FIN
segment, and send an ACK to the client. Server now enters a
<strong>Close Wait (Passive Close)</strong> state. Server will release
any buffer resources, because client has said it doesn’t want to send
any more data to server. (Server may still have data to send to the
client).</p>
<p>When the client receives the ACK from server, it enters
<strong>FIN_WAIT_2</strong> state. In this state, the client is waiting
for the server to send a segment with FIN bit set as 1 (i.e, client is
waiting for server to also close the connection.)</p></li>
<li><p><strong>FIN from Server</strong> - Server can send any pending
data, and then it will send a segment with FIN bit as 1. Server now
enters <strong>LAST_ACK</strong> state. In this state, the server only
expects to receive one last ACK from the client (for the FIN segment
server just sent). After receiving the ACK, Server will release all
resources for this connection, and the connection will be
closed.</p></li>
<li><p><strong>ACK from Client</strong> - Client will receive the
server’s FIN segment, and send an ACK for it. Client will enter
<strong>TIME_WAIT</strong> state. In this, the client waits in case the
final ACK was lost. If the final ACK was lost, the server will timeout
and resend the FIN message. If the client receives any FIN message in
the <strong>TIME_WAIT</strong> state, it will resend the ACK. If it
doesn’t, client assumes the last ACK was successfully delivered, and it
will close the connection.</p>
<p>The amount of time to be waited varies, but it’s generally 30s or 1
min.</p></li>
</ol>
<figure>
<img src="../images/cn/tcp_state_diagram.png" alt="TCP State Diagram" />
<figcaption aria-hidden="true">TCP State Diagram</figcaption>
</figure>
<p>Dashed lines are for server, solid for client.</p>
<h4 id="tcp-congestion-control">TCP Congestion Control</h4>
<p>Congestion Window is used for congestion control. Size of congestion
window changes throughout the TCP connection. We first increase it, to
send more data in less time. In case congestion occurs while increasing,
we again decrease it.</p>
<p>Concept of MSS (Maximum Segment Size) is used.</p>
<p>Congestion Control in TCP has 3 phases:</p>
<ol type="1">
<li><p><strong>Slow Start Phase (Exponential Growth)</strong> - In this,
the congestion window is increased exponentially. Initially, the window
size is 1 MSS. Then it becomes 2 MSS, then 4, then 8, then 16, and so
on, until the <em>slow start threshold</em>. Slow Start Threshold is
determined as <span class="math display">\[
(Receiver Window Size/MSS)/2
\]</span> This gives max number of segments in slow start phase (not
their size.)</p></li>
<li><p><strong>Congestion Avoidance Phase (Linear Growth)</strong> -
Congestion Window grows linearly. If it at <span
class="math inline">\(x\)</span> MSS , it becomes <span
class="math inline">\(x+1\)</span>, then <span
class="math inline">\(x+2\)</span>, and so on.</p>
<p>This continues until congestion window size becomes equal to receiver
window size. After that, we keep congestion window size as
constant.</p></li>
<li><p><strong>Congestion Detection</strong> - Congestion is detected in
this phase, and we change window size to accommodate it.</p>
<p>There are two ways in which congestion can be detected:</p>
<ol type="1">
<li><p><strong>Time-Out</strong> - When timer times out before we
receive an ACK. Congestion in this case is Severe.</p></li>
<li><p><strong>3-ACK</strong>- Sender receives 3 duplicate ACKs for the
same segment. Congestion in this case is light.</p>
<p>For e.g, if sender sent packets 1,2,3,4 and 5. Receiver received
packet 1 and sent ACK 2 (Original ACK). Packet 2 was lost. Receiver
received packet 3, and again sent ACK 2 (because it hasn’t received
packet 2). Receiver received packet 4, and again sent ACK 2. Similarly
for packet 5. Sender will thus receive 4 ACKS - 1 original, and 3
duplicate acknowledgments for packet 2.</p></li>
</ol></li>
</ol>
<h5 id="reaction-in-congestion-detection">Reaction in Congestion
Detection</h5>
<h6 id="time-out">Time-Out</h6>
<ol type="1">
<li>Slow Start Threshold is set as half of current window size. For e.g,
if current window size is 16 MSS, slow start threshold will be 8.</li>
<li>Congestion window is reset to be equal to 1 MSS.</li>
<li>Slow Start Phase is resumed</li>
</ol>
<h6 id="ack-1">3-ACK</h6>
<ol type="1">
<li>Slow Start Threshold is set as half of current window size.</li>
<li>Congestion window is set equal to slow start threshold</li>
<li>Congestion Avoidance phase is resumed</li>
</ol>
<h4 id="tcp-timers">TCP Timers</h4>
<h5 id="retransmission-timer">Retransmission Timer</h5>
<ul>
<li>TCP start timer after each transmission. If an ACK is not received
before this timer runs out, the segment is retransmitted.</li>
<li>The amount of time it waits is called RTO (Retransmission
Timeout)</li>
<li>RTO is calculated using RTT, there are many ways to do so.</li>
</ul>
<h5 id="time-wait-timer">Time-Wait Timer</h5>
<ul>
<li>Takes care of late packets</li>
<li>Never close a TCP connection immediately. Wait for 2*LT, so that any
delayed packets can arrive.</li>
</ul>
<h5 id="keep-alive-timer">Keep-Alive Timer</h5>
<ul>
<li>Used to close idle connections.</li>
<li>Periodically check connections, and close them if no reply.</li>
<li>After keep-alive time duration, server will send 10 probe messages
with gap of 75 seconds. If no reply, the connection is closed.</li>
<li>Keep-alive time duration is generally 2 hours.</li>
</ul>
<h5 id="persistent-timer">Persistent Timer</h5>
<ul>
<li>Suppose receiver’s buffer is full, so it sends an ACK to sender with
window-size=0</li>
<li>Sender understands that it cannot send more data as receiver buffer
is full, and it waits.</li>
<li>Receiver processes the data in buffer and empties it. Now it has
space, so it sends another ACK to server with window-size = some
non-zero value. Suppose this ACK gets lost.</li>
<li>Now, sender is waiting for receiver to empty its buffer, and
receiver is waiting for sender to send data. This is a
<strong>deadlock</strong>.</li>
<li>To prevent this, persistent timer is use. When sender receives a
packet with window size=0, it will start a persistent timer.</li>
<li>After that timer goes off, it will send a probe with only 1 byte of
new data. The receiver will receive this probe and send its new window
size.</li>
<li>If the new window size is non-zero, the sender will start
transmitting data. If it is still zero, the sender will start the
persistent timer again and wait.</li>
</ul>
<h3 id="udp">UDP</h3>
<p>UDP (User Datagram Protocol) is another transport layer service. It’s
popular applications include DNS, VoIP, etc.</p>
<h4 id="characteristics-1">Characteristics</h4>
<ul>
<li>Connectionless</li>
<li>Unreliable</li>
<li>Messages may be delivered out of order.</li>
<li>Less overhead, as header is very small.</li>
<li>Faster than TCP.</li>
</ul>
<h4 id="header">Header</h4>
<figure>
<img src="../images/cn/udp-header.png" alt="UDP Header" />
<figcaption aria-hidden="true">UDP Header</figcaption>
</figure>
<ul>
<li>Header size is fixed at 8 bytes.</li>
<li>Length contains total length (header+data)</li>
<li>Maximum length of UDP datagram is <span
class="math inline">\(2^{16}\)</span> bytes (including header)</li>
<li>Checksum field is optional in IPv4, mandatory in IPv6.</li>
</ul>
<h4 id="udp-applications">UDP Applications</h4>
<ul>
<li><strong>Query-Response Protocol</strong> (One query-One reply, no
need to make a connection as we only need one reply). For e.g - DNS</li>
<li><strong>Speed</strong> - When we need high-speed applications. For
e.g. - Online games, VoIP.</li>
<li><strong>Broadcasting/Multicasting</strong>- Eg, RIP (Routing
Information Protocol), Distance Vector Routing. Nodes share routing
tables after every 30 seconds, to <em>all other nodes</em>. If we use
TCP, the node will have to establish connections with all other nodes,
which will be time consuming.</li>
<li><strong>Continuous Streaming</strong>- E.g, Skype/YouTube.</li>
<li><strong>Stateless</strong> - Don’t save information about the
connecting clients.</li>
</ul>
<h3 id="tcp-vs-udp">TCP vs UDP</h3>
<table>
<colgroup>
<col style="width: 46%" />
<col style="width: 53%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">TCP</th>
<th style="text-align: center;">UDP</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">Connection-Oriented</td>
<td style="text-align: center;">Connectionless</td>
</tr>
<tr class="even">
<td style="text-align: center;">Reliable</td>
<td style="text-align: center;">Unreliable</td>
</tr>
<tr class="odd">
<td style="text-align: center;">In-order Delivery</td>
<td style="text-align: center;">Delivery may be out of order</td>
</tr>
<tr class="even">
<td style="text-align: center;">Error Control is Mandatory</td>
<td style="text-align: center;">Error control is optional</td>
</tr>
<tr class="odd">
<td style="text-align: center;">Slow</td>
<td style="text-align: center;">Fast</td>
</tr>
<tr class="even">
<td style="text-align: center;">More Overhead</td>
<td style="text-align: center;">Less overhead</td>
</tr>
<tr class="odd">
<td style="text-align: center;">Flow Control, Congestion Control</td>
<td style="text-align: center;">No flow control or congestion
control</td>
</tr>
<tr class="even">
<td style="text-align: center;">HTTP, FTP</td>
<td style="text-align: center;">DNS,BOOTP,DHCP</td>
</tr>
</tbody>
</table>
<h2 id="application-layer">Application Layer</h2>
<p>Enables users (human or s/w) to access the network. It is responsible
for providing services to the user.</p>
<h3 id="paradigms">Paradigms</h3>
<ul>
<li>Provides services to the user</li>
<li>To use the internet we need 2 application programs that communicate
with each other using the application layer.</li>
<li>Communication uses a logical connection, i.e, the 2 application
programs assume that there is an imaginary direct connection between
them. In reality, the communication happens through various layers
(Transport, Network, Data-Link, etc.)</li>
</ul>
<p>There are 2 types:</p>
<ul>
<li><strong>Client-Server</strong> - Server program provides service to
the client program. It is the most popular method today. Server runs
continuously. Client creates a connection to the server using the
Internet and requests a particular service.</li>
<li><strong>Peer to Peer</strong> - Gaining popularity in recent times.
Both communicating programs have equal responsibility and power. No
program needs to be always running. A computer can even provide and
receive services at the same time.</li>
</ul>
<h3 id="file-transferring">File Transferring</h3>
<h4 id="ftp-file-transfer-protocol">FTP (File Transfer Protocol)</h4>
<ul>
<li>It’s an application layer protocol used for transferring (uploading
and downloading) files over the Internet.</li>
<li>It uses TCP under the hood.</li>
<li>It solves problems such as different systems having different ways
of representing and storing files.</li>
<li>It establishes 2 connections between 2 hosts:
<ul>
<li>One connection is used for control information (commands and
responses). This uses TCP port 21. It remains active during the FTP
session.</li>
<li>The other connection is used for actual data transfer. This uses TCP
port 20. It closes and opens for each file transfer.</li>
</ul></li>
</ul>
<h5 id="security-in-ftp">Security in FTP</h5>
<p>SSL (Secure Sockets Layer) can be added to FTP (between FTP and TCP)
to make it more secure. This makes it SSL-FTP.</p>
<h3 id="email">Email</h3>
<ul>
<li>Used to send messages over the Internet</li>
<li>Used to be plain text, now can include images, videos, files,
etc.</li>
<li>Actual message transfer is done using a message transfer agent
(MTA). Client must have client MTA to send mail, server must have server
MTA to receive mail.</li>
</ul>
<h4 id="smtp">SMTP</h4>
<p>SMTP (Simple Mail Transfer Protocol) is the formal protocol that
defines MTA client and server applications. SMTP defines how commands
and responses must be sent back and forth. It is used twice, once
between sender and sender’s mail server, and second between sender’s
mail server and receiver’s mail server. Mail is transferred in 3 phases
- Connection Establishment, Mail Transfer, and Connection
Termination.</p>
<h4 id="message-access-agents---pop-and-imap">Message Access Agents -
POP and IMAP</h4>
<ul>
<li>SMTP is not involved in pulling mail to client. It is only a push
protocol and pushes mail from client to server.</li>
<li>Message Access Agents such as POP (Post Office Protocol) and IMAP
(Internet Mail Access Protocol) are used to pull messages from the
server.</li>
</ul>
<h5 id="pop3">POP3</h5>
<ul>
<li>Simple and limited.</li>
<li>Client opens connection to server on port 110. It sends its username
and password.</li>
<li>It can access mail messages in delete mode or keep mode. In delete
mode, once a message is downloaded from the server, the server will
delete it. The user can keep a local copy. In keep mode, the server side
copy will be kept intact.</li>
</ul>
<h5 id="imap4">IMAP4</h5>
<ul>
<li>More powerful and complex.</li>
<li>User can check email header before downloading the entire
message.</li>
<li>User can search email</li>
<li>Partially downloadable email</li>
<li>Different mailboxes, folders, hierarchy of folders can be
created.</li>
</ul>
<h3 id="dns">DNS</h3>
<p>DNS stands for domain name system. It is used to convert domain
names, such as google.com, to IP addresses, such as 8.8.8.8. Special DNS
servers are used for this. Many of them exist due to the large number of
websites on the internet that need DNS services.</p>
<h4 id="dns-server-hierarchy">DNS Server Hierarchy</h4>
<h5 id="root-dns-server">Root DNS Server</h5>
<p>This is the highest level in the hierarchy. Many of these exist, and
are operated by very few organizations (around 13). When a root DNS
server is asked to provide the IP of a website, it doesn’t provide the
IP directly. Instead, it provides the IP of the correct TLD DNS server
that will contain the needed website’s IP.</p>
<h5 id="top-level-domain-tld-dns-server">Top-Level Domain (TLD) DNS
Server</h5>
<p>TLDs are used for a particular domain ending - for e.g, .com, .edu,
.in, etc. Each will have a different TLD server. The TLD will point the
query towards the correct authoritative DNS server that contains the
website’s IP.</p>
<h5 id="authoritative-dns-server">Authoritative DNS Server</h5>
<p>Authoritative DNS servers contain a broad list of domain names and
their IP addresses. The authoritative DNS server will return back a
website’s IP address to us.</p>
<h4 id="dns-name-hierarchy">DNS Name Hierarchy</h4>
<p>Suppose we take the domain - www.example.com</p>
<p>A fully qualified domain name (FQDN) always has a . at the end, even
if we don’t write it. So our domain becomes www.example.com.</p>
<p>This can be divided into 4 parts, from right to left.</p>
<ol type="1">
<li><strong>The root level domain</strong> - Represented by the dot at
the end, this is the highest hierarchy level. It is used to denote the
root level DNS server.</li>
<li><strong>TLD</strong> - The TLD in our case is <em>com</em></li>
<li><strong>Second-level domain</strong>- This is the website’s name,
for e.g a business name. In our case it is <em>example</em></li>
<li><strong>Sub-domain</strong> - Here, <em>www</em> is a subdomain. We
can also create more subdomains such as shop.example.com,
cloud.example.com, images.example.com, etc.</li>
</ol>
<h2 id="session-layer">Session Layer</h2>
<h3 id="functions-of-session-layer">Functions of Session Layer</h3>
<ul>
<li>Dialog Control - allow systems to enter into full/half duplex
dialog</li>
<li>Managing tokens</li>
<li>Synchronization</li>
</ul>
<h3 id="design-issues">Design Issues</h3>
<ul>
<li>Establishing sessions between 2 machines - opening, closing and
maintaining a semi-permanent dialogue.</li>
<li>Enhanced services (checkpoints and tokens)</li>
</ul>
<h3 id="rpc-remote-procedure-call">RPC (Remote Procedure Call)</h3>
<p>RPC is a protocol that works in session layer of OSI model, and
application layer of TCP/IP model.</p>
<ul>
<li>RPC is when a client calls a service on a server (or any other
network computer), as if it is calling a function on its own local
system.</li>
<li>Can work on TCP/UDP both, but prefers UDP.</li>
<li>Uses authentication to verify client’s identity.</li>
</ul>
<p>Client -&gt; Client Side API —– RPC ——&gt; Server -&gt; Local
function call -&gt; Return value to client.</p>
<ul>
<li>Client doesn’t see the OSI layers or the network calls. To the
client, it is simply calling a function.</li>
<li><strong>Stubs</strong> are used to convert data to different
formats, as client and server may use different formats for data.</li>
<li>The client stub takes the parameters for the RPC call and puts them
into the message. This is called <strong>parameter marshalling</strong>.
It also puts the name or number of the procedure to be called.</li>
<li>The receiver stubs receives the message, unpacks it and gives it to
the receiver application. The receiver application calls the requested
procedure with the given parameters. The result is packet into a message
by the receiver stub, and send to the client.</li>
<li>The client stub receives the response, unpacks it, and gives it back
to the client application.</li>
</ul>
<h4 id="issues-in-rpc">Issues in RPC</h4>
<ul>
<li><p><strong>Binding</strong> - How does the client know who to call,
what the procedure name is, etc.?</p>
<p>This has 2 solutions:</p>
<ul>
<li><strong>Dynamic Binding</strong> - Find the server when RPC is
called (at runtime)</li>
<li><strong>Naming and Locating</strong> - Server offering a service
exports an interface for it, and registers the interface with the
system. Client must import an interface before communication.</li>
</ul></li>
<li><p>Different formats of data - solved by stubs.</p></li>
<li><p>How to pass parameters - solved by parameter
marshalling.</p></li>
</ul>
<h2 id="presentation-layer---security">Presentation Layer -
Security</h2>
<p>One of the major functions of the presentation layer is security and
cryptography.</p>
<h3 id="types-of-cryptosystems">Types of Cryptosystems</h3>
<h4 id="symmetric">Symmetric</h4>
<p>AKA conventional cryptography/shared-key systems/secret-key
systems.</p>
<p>Sender and receiver share the same key, which is used both for
encryption and decryption.</p>
<p>The shared key must be kept private. Anyone in possession of the key
can read encrypted messages.</p>
<p>The notation <span class="math inline">\(K_{a,b}\)</span> is used to
denote a secret-key shared by <span class="math inline">\(A\)</span> and
<span class="math inline">\(B\)</span>.</p>
<h4 id="asymmetric">Asymmetric</h4>
<p>AKA Public-key cryptography.</p>
<p>The keys for encryption and decryption are different, but form a
unique pair. The key for decryption can only decrypt the data encrypted
with its pair key.</p>
<p>Key for encryption - <span class="math inline">\(K_E\)</span>.</p>
<p>Key for decryption - <span class="math inline">\(K_D\)</span>.</p>
<p>One of the keys is made public, and the other one kept private.</p>
<p>The notation <span class="math inline">\(K_A^+\)</span> is used to
denote a public key belonging to <span class="math inline">\(A\)</span>,
and <span class="math inline">\(K_A^-\)</span> denotes a private key
belonging to <span class="math inline">\(A\)</span>.</p>
<p>If Bob wants to send a message to Alice, he should encrypt it using
Alice’s public key. Since Alice is the only person who possessed the
corresponding private key, only she can decrypt the message.</p>
<h3 id="types-of-ciphers">Types of Ciphers</h3>
<p>Ciphers are algorithms used to change <em>plaintext</em> to
<em>ciphertext</em>. Plaintext is our original information. Ciphertext
is it’s encrypted form. A cipher does character-to-character, or
bit-to-bit transformations. A code, on the other hand, transforms entire
words.</p>
<h4 id="substitution-ciphers">Substitution Ciphers</h4>
<p>Each letter is replaced, or substituted, by another letter. It can
also be done for groups of letters, for e.g, two at a time.</p>
<p>A simple example is the Caesar cipher, in which the letters of the
alphabet are shifted a fixed number of positions. For e.g, if we shift
by 2,</p>
<p>A becomes C, B becomes D, C becomes E, etc.</p>
<p>Modern substitution ciphers are much more complex, and tough to
break.</p>
<h4 id="transposition-ciphers">Transposition Ciphers</h4>
<p>In substitution ciphers, we changed the letters/bits, but kept their
order the same. In transposition ciphers, we will keep the letters the
same, but change their order.</p>
<p>One simple transposition cipher is the columnar transposition, shown
here.</p>
<figure>
<img src="../images/cn/transposition_cipher.png"
alt="image-20230506141817783" />
<figcaption aria-hidden="true">image-20230506141817783</figcaption>
</figure>
<p>Here, MEGABUCK is the secret key that must not be shared with anyone
except the receiver. We write the plaintext rowwise, with the number of
columns being the length of the key.</p>
<p>We write the ciphertext columnwise. We start with the column whose
key is lowest. Here, lower is determined by position in alphabet. Thus,
we write out column A -&gt; B-&gt;C-&gt;E-&gt;G-&gt;K-&gt;M.</p>
<h3 id="rsa">RSA</h3>
<p>An asymmetric encryption algorithm named after its inventors -
Rivest, Shamir and Adleman.</p>
<p>Based on the fact that prime factorization of very large numbers is a
difficult and time-consuming process.</p>
<h4 id="steps">Steps</h4>
<ol type="1">
<li><p>Take 2 very large prime numbers - <span
class="math inline">\(p\)</span> and <span
class="math inline">\(q\)</span>.</p></li>
<li><p>Calculate <span class="math display">\[ n = p * q \]</span> <span
class="math display">\[ z = (p-1)*(q-1) \]</span></p></li>
<li><p>Choose <span class="math inline">\(d\)</span> such that <span
class="math inline">\(d\)</span> is relatively prime to <span
class="math inline">\(z\)</span>.</p></li>
<li><p>Compute <span class="math inline">\(e\)</span> such that</p></li>
</ol>
<p><span class="math display">\[ (e*d)\%z =1 \]</span></p>
<p>Now, the number <span class="math inline">\(d\)</span> can be used
for decryption, and <span class="math inline">\(e\)</span> for
encryption.</p>
<p>One of these is kept private, and the other is made public.</p>
<h4 id="usage">Usage</h4>
<p>Let the message to be sent be <span class="math inline">\(m\)</span>.
Here, <span class="math inline">\(m\)</span> is interpreted simply as a
binary number.</p>
<ol type="1">
<li>Divide <span class="math inline">\(m\)</span> into fixed length
blocks, <span class="math inline">\(m_i\)</span>, such that:</li>
</ol>
<p><span class="math display">\[ 0 \le m_i \le n \]</span></p>
<p>Each <span class="math inline">\(m_i\)</span> is also interpreted as
a binary number.</p>
<ol start="2" type="1">
<li><p>The sender calculates <span class="math display">\[ c_i = (m_i^e)
\% n \]</span> All such <span class="math inline">\(c_i\)</span> are
calculated and concatenated into a single variable <span
class="math inline">\(c\)</span>.</p></li>
<li><p><span class="math inline">\(c\)</span> is sent to the
receiver.</p></li>
<li><p>The receiver calculates <span class="math display">\[ y_i =
(c_i^d) \% n \]</span></p></li>
</ol>
<p>Based on the properties of modulus, and the way we have chosen <span
class="math inline">\(e\)</span> and <span
class="math inline">\(d\)</span>, we can easily see that <span
class="math inline">\(y_i=m_i \forall i\)</span>.</p>
<p>This way, the receiver is able to reconstruct the message.</p>
<h4 id="properties-of-rsa">Properties of RSA</h4>
<ul>
<li>RSA is secure because no method exist to (efficiently) find prime
factors of large numbers.</li>
<li>RSA itself is also computationally expensive, around 100-1000x
slower than DES.</li>
<li>It’s generally used to securely share session keys, and then those
session keys are used in a (faster) encryption algorithm, such as AES or
DES.</li>
</ul>
<h3 id="securely-sending-messages-secure-channels">Securely sending
messages (Secure Channels)</h3>
<p>Securely sending messages has the following problems to solve.</p>
<ul>
<li><p><strong>Confidentiality</strong></p>
<p>No one else other than the intended recipient should be able to read
the message.</p></li>
<li><p><strong>Integrity</strong></p>
<p>The recipient should have a way to be sure that the contents of the
message weren’t tampered.</p></li>
<li><p><strong>Authentication</strong></p>
<p>Both parties should have a way to be confident that they are sending
messages to the right person.</p></li>
</ul>
<h4 id="digital-signatures">Digital Signatures</h4>
<p>Confidentiality and Integrity needs to be maintained in secure
channels.</p>
<ul>
<li>Alice needs to be sure that Bob cannot alter a message and claim
that Alice sent it.</li>
<li>Bob needs to be able to prove that a message indeed came from Alice,
and that she cannot deny having sent it.</li>
</ul>
<p><strong>Digital Signatures</strong> are used for this. The document
is signed using the sender’s public key, which uniquely ties the sender
to the message.</p>
<ul>
<li>Alice sends a message <span class="math inline">\(m\)</span> to Bob.
She encrypts it with <em>her</em> private key to create a
<strong><em>signature</em></strong>. The signature and the original
message are sent to Bob.
<ul>
<li>If she wants to keep the message content a secret, she can encrypt
the entire thing using Bob’s public key.</li>
<li>The message will then be <span
class="math inline">\(K_B^+(m,K_A^-(m))\)</span>, where <span
class="math inline">\(K_A^-(m)\)</span> is the signature.</li>
</ul></li>
<li>Message arrives at Bob.
<ul>
<li>If it’s secret, he first decrypts it using his private key.</li>
</ul></li>
<li>He decrypts the signature using Alice’s public key, and matches it
with <span class="math inline">\(m\)</span>. If the decrypted signature
and <span class="math inline">\(m\)</span> match, then he can be sure
the message was sent from Alice and is untampered with.</li>
<li>Alice cannot claim she never sent the message, or sent a different
message, because Bob has the signed version of <span
class="math inline">\(m\)</span>, and only Alice could have signed it,
since only she possesses her private key.</li>
<li>Bob cannot claim Alice sent a modified message, because he would
have to prove that Alice signed the modified message as well.</li>
</ul>
<figure>
<img src="../images/obs/digital_signatures.png"
alt="Digitally signing messsages" />
<figcaption aria-hidden="true">Digitally signing messsages</figcaption>
</figure>
<h5 id="issues-with-this-scheme">Issues with this scheme</h5>
<ul>
<li>This remains valid only as long as Alice’s private key remains
private. If the key is stolen or leaked, Alice will have to generate a
new key, and all messages signed using the previous key will then become
worthless.</li>
<li>If the message is long, encrypting the entire message may be
computationally expensive.</li>
</ul>
<p>A solution for the second problem is a <strong>message
digest</strong>.</p>
<h5 id="message-digest">Message Digest</h5>
<p>It’s a fixed length string <span class="math inline">\(h\)</span>
that’s computed from a message <span class="math inline">\(m\)</span> of
arbitrary length, using a hash function <span
class="math inline">\(H\)</span>.</p>
<p>If <span class="math inline">\(m\)</span> is changed to <span
class="math inline">\(m&#39;\)</span>, then it’s hash <span
class="math inline">\(H(m&#39;)\)</span> will not be the same as before
(<span class="math inline">\(H(m)\)</span>). Thus, modifications will
easily be detected.</p>
<p>Instead of signing <span class="math inline">\(m\)</span>, Alice
signs <span class="math inline">\(H(m)\)</span>, which becomes the
signature.</p>
<p>The message sent to Bob is now <span
class="math inline">\(K_B^+(m,K_A^-(H(m)))\)</span>, where <span
class="math inline">\(K_A^-(H(m))\)</span> is the signature.</p>
<p>On Bob’s end, Bob will hash the entire message himself, decrypt the
signature, and compare the hashes. If they match, all is good.</p>
<figure>
<img src="../images/obs/digital_signatures_using_digest.png"
alt="Digitally signing messages using digests" />
<figcaption aria-hidden="true">Digitally signing messages using
digests</figcaption>
</figure>
</div></div></body>
</html>
